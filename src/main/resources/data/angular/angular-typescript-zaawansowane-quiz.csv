Pytanie;Opcja0;Opcja1;Opcja2;Opcja3;indeks_poprawnej
Co to są Utility Types i jakie znasz?;Utility Types to zaawansowane funkcje runtime które operują na obiektach JavaScript, pozwalając na dynamiczną manipulację typami podczas wykonywania programu. Działają w połączeniu z reflection API;Utility Types to zabudowane typy które transformują inne typy. Partial<T> (wszystkie opcjonalne), Required<T>, Record<K,V>, Pick, Omit, Readonly<T>, Keyof T;Utility Types to deprecated mechanizm z wczesnych wersji TypeScript 2.0, który został zastąpiony przez bardziej elastyczne Mapped Types w wersji 4.0. Należy migrować starszy kod;Utility Types to ograniczony zestaw obejmujący tylko Partial i Required - wszystkie pozostałe 'utility types' jak Pick, Omit czy Record to tak naprawdę custom types definiowane przez użytkownika;1
Jak używać keyof do iteracji po kluczach?;keyof to przestarzały operator który został całkowicie zastąpiony przez Object.keys() w TypeScript 4.0. Nowsze projekty powinny używać runtime reflection zamiast compile-time keyof;type Keys = keyof User; // 'id' | 'name'. W Mapped Types: type Getters<T> = { [K in keyof T]: () => T[K]; }. Dynamiczne iterowanie po właściwościach;keyof działa wyłącznie dla interfejsów zdefiniowanych przez keyword interface - nie można użyć keyof z type aliases. Próba użycia keyof Type powoduje compiler error;keyof zwraca array kluczy zamiast union type, więc wymaga dodatkowego mappingu: type Keys = keyof User[number] aby uzyskać string literal union. Nieergonomiczna składnia;1
Co to są Conditional Types i kiedy ich używać?;Conditional Types to dynamiczna logika wykonywana w runtime która sprawdza typy zmiennych podczas działania programu. Wymaga import 'reflect-metadata' i dekoratorów dla type checking w runtime;Conditional Types to warunkowa logika w typach: type IsString<T> = T extends string ? true : false;. Z infer: type Flatten<T> = T extends Array<infer U> ? U : T;. Zaawansowane dla bibliotek;Conditional Types nie istnieją w TypeScript jako built-in feature - to experimental functionality dostępna tylko przez compiler flag --experimentalConditionalTypes w tsconfig;Definiuje się je używając condition<T> jako keyword przed definicją typu: condition<T> T extends string ? A : B. TypeScript wymaga słowa kluczowego dla rozpoznania conditional syntax;1
Jak stworzyć generyczną funkcję helper?;function pick<T, K extends keyof T>(obj: T, ...keys: K[]): Pick<T, K>. K extends keyof T gwarantuje że K to prawidłowe klucze z T. Type-safe helper'y;Generyczne funkcje nie mogą mieć constraints na parametrach typu - wszystkie generic parameters muszą być unconstrained. Constraints jak extends działają tylko w klasach nie w funkcjach;Definiuję używając helper<T> jako specjalnego typu funkcji: helper<T> function pick(obj: T). TypeScript wymaga helper keyword dla rozpoznania generic utility functions;Funkcje helper nie mogą wykorzystywać Utility Types jak Pick czy Omit - te typy działają tylko w deklaracjach type alias, nie w return types funkcji. Trzeba używać custom return types;0
