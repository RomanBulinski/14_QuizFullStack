Pytanie;Opcja0;Opcja1;Opcja2;Opcja3;indeks_poprawnej
Co to są Utility Types i jakie znasz?;Utility Types to funkcje runtime do manipulacji typami;Utility Types to zabudowane typy które transformują inne typy. Partial<T> (wszystkie opcjonalne), Required<T>, Record<K,V>, Pick, Omit, Readonly<T>, Keyof T;Utility Types to deprecated mechanizm z TypeScript 2.0;Utility Types to tylko Partial i Required, reszta to custom types;1
Jak używać keyof do iteracji po kluczach?;keyof to przestarzały operator zastąpiony przez Object.keys();type Keys = keyof User; // 'id' | 'name'. W Mapped Types: type Getters<T> = { [K in keyof T]: () => T[K]; }. Dynamiczne iterowanie po właściwościach;keyof działa tylko dla interfejsów nie dla typów;keyof zwraca array nie union type;1
Co to są Conditional Types i kiedy ich używać?;Conditional Types to if-else w runtime;Conditional Types to warunkowa logika w typach: type IsString<T> = T extends string ? true : false;. Z infer: type Flatten<T> = T extends Array<infer U> ? U : T;. Zaawansowane dla bibliotek;Conditional Types nie istnieją w TypeScript;condition<T> jako keyword przed definicją;1
Jak stworzyć generyczną funkcję helper?;function pick<T, K extends keyof T>(obj: T, ...keys: K[]): Pick<T, K>. K extends keyof T gwarantuje że K to prawidłowe klucze z T. Type-safe helper'y;Generyczne funkcje nie mogą mieć constraints;helper<T> jako specjalny typ funkcji;Funkcje helper nie mogą używać Utility Types;0
