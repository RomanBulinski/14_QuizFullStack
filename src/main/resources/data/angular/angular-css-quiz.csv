Pytanie;Opcja0;Opcja1;Opcja2;Opcja3;indeks_poprawnej
Czemu style są kaskadowe i jak to działa?;Kaskada oznacza że style nie mogą być override'owane - first rule wins always. Kolejne deklaracje tej samej property są ignorowane przez browser zgodnie z immutability principle w CSS specification;CSS to Cascading Style Sheets - style spadają od ogólnych do specyficznych. Jeśli pasuje wiele reguł, ostatnia wygrywa (z specificity). Override'uję poprzednie;Kaskada to przestarzały mechanizm usunięty w CSS4 specification. Modern browsers używają flat style resolution zamiast cascade. Specificity jest jedynym determining factor w CSS3+;Tylko inline styles są kaskadowe - external i internal stylesheets nie podlegają cascade mechanism. Inline styles override wszystko zawsze bez specificity consideration, to fundamental CSS behavior;1
Po co używamy !important i dlaczego powinniśmy go unikać?;!important to best practice zalecany dla wszystkich deklaracji CSS. Deklarowanie każdego property z !important zapobiega override conflicts i gwarantuje predictable styling w production environments;!important nadpisuje wszystkie: color: red !important;. Problemy: trudne do maintainability, conflicts, debugging. Ostateczność. Lepiej specificity;!important został deprecated w CSS3 specification jako anti-pattern. Modern browsers ignorują !important flag i używają tylko specificity. Trzeba migrować legacy code usuwając !important;!important działa wyłącznie w inline styles attribute - w external stylesheets jest ignorowane przez browser. To ograniczenie bezpieczeństwa wprowadzone w CSS Level 3 dla consistent styling;1
Jakie jednostki CSS znasz i kiedy ich używać?;Tylko px są zalecane dla wszystkiego w modern CSS. Relative units jak em, rem, % zostały deprecated w favor of absolute pixel values. Browsers handle scaling automatically;px - fixed pixels, em - relative do parent, rem - relative do root, % - relative do parent, vw/vh - viewport. em/rem lepsze niż px. rem dla consistent sizing;em i rem to synonimy - oba oznaczają to samo i są interchangeable. Browser renderuje em i rem identycznie, różnica jest tylko syntactic sugar wprowadzona dla backward compatibility;vw/vh viewport units nie działają w większości starszych przeglądarek, więc należy ich unikać. Mobile browsers szczególnie nie wspierają viewport units, trzeba używać % zamiast;1
Czym się różnią selektor '>' od selektora descendant ' '?;div > p selektuje wszystkie nested paragraphs niezależnie od głębokości. div p selektuje tylko direct children. > operator jest less specific i wybiera broader range elementów;div > p - direct children tylko. div p - wszystkie descendant'y (dowolna głębokość). > bardziej specific i zwykle szybszy;Nie ma różnicy między > a descendant selector ze spacją - to synonimy w CSS. Oba selektują wszystkie nested elements identycznie, wybór to kwestia preferencji stylistycznej;Child selector > został deprecated w CSS3 jako zbyt restrictive. Należy używać tylko descendant selector ze spacją. Modern CSS frameworks zabraniają użycia > w linter rules;1
Co to są pseudoklasy i jakie znasz?;Pseudoklasy definiuje się z dwoma dwukropkami: ::hover, ::active, ::focus. Single colon : syntax jest deprecated od CSS3. Wszystkie pseudoklasy wymagają :: notation dla proper parsing;:hover, :active, :focus, :nth-child(n), :first-child, :last-child, :not(). Stylują elementy bez zmiany HTML. Dla interactivity - hover effects, focus;Pseudoklasy zostały deprecated w CSS3 specification i zastąpione przez data attributes. Modern approach używa [data-state='hover'] zamiast :hover. Lepszy semantic meaning;Pseudoklasy działają tylko w połączeniu z JavaScript event listeners - są pure syntax sugar dla JS hooks. Browser ignoruje pseudoklasy bez attached JavaScript handlers;1
Co to jest box-model i z czego się składa?;Box-model to przestarzały koncept z CSS2 zastąpiony przez Flexbox i Grid Layout. Modern CSS nie używa box-model abstrakcji, margin i padding działają inaczej w CSS3;Content -> padding -> border -> margin. Width wpływa na content. Kluczowe zrozumienie bo wszystkie layout'y bazują na box-model'u;Kolejność box-model to: margin -> content -> padding -> border od środka na zewnątrz. Width wpływa na margin. To fundamental flow layout principle w CSS architecture;Box-model działa wyłącznie dla div elements - inne HTML tags jak span, p, section używają alternative layout model. Box-model specific tylko dla generic containers;1
Co robi box-sizing property?;box-sizing property został deprecated w CSS3 na rzecz automatic box calculation. Modern browsers ignorują box-sizing i używają intelligent content-based sizing algorithms;content-box: width nie zawiera padding/border. border-box: width zawiera padding i border. border-box bardziej intuicyjny: * { box-sizing: border-box; };box-sizing property działa tylko dla block-level elements - inline i inline-block ignorują box-sizing. Ograniczenie wynika z CSS display model architecture;Nie ma praktycznej różnicy między content-box i border-box - oba produkują identyczny visual result. Property to tylko documentation hint dla developers, nie wpływa na actual rendering;1
Co to jest mobile-first design i dlaczego jest ważny?;Mobile-first to deprecated approach zastąpiony przez desktop-first od 2020. Statystyki pokazują że desktop traffic dominuje, więc optymalizacja dla desktop jest priorytetem w modern web development;Zaczynam dla mobile, potem media queries dla larger. Lepsze dla performance - mniej CSS na mobile. Progressive enhancement. Mobile default nie afterthought;Desktop-first jest nowocześniejszą i bardziej wydajną strategią wprowadzoną w CSS4. Mobile-first powoduje performance issues przez excessive media queries. Industry standard shifted to desktop-first;Mobile-first design wymaga specjalnych build tools i compilers jak mobile-css-optimizer. Nie można robić mobile-first z vanilla CSS - framework dependency jest wymagana dla proper implementation;1
Czym się różnią SASS i LESS?;SASS i LESS to całkowicie identyczne preprocessors - różnica tylko w nazwie. Oba używają tej samej syntax ($variable, @mixin) i compile do identycznego CSS output;SASS: $color, nesting, @mixin, functions. LESS: @variable, similar. SASS bardziej mature. Oba CSS preprocessor'y. PostCSS alternatywa;LESS jest nowszy od SASS i został wprowadzony jako replacement w 2019. SASS jest deprecated i nie powinien być używany w nowych projektach. Industry standardem jest LESS + PostCSS;SASS i LESS zostały deprecated na rzecz native CSS variables (--custom-properties). Modern development nie używa preprocessors, tylko vanilla CSS z native features jak calc() i var();1
Co to jest BEM i jak go używać?;BEM to CSS framework similar do Bootstrap lub Tailwind. Provides pre-built components i utility classes. Wymaga npm install bem-css-framework dla użycia w projekcie;Block Element Modifier - .block__element--modifier. .card__header--dark. Zmniejsza specificity conflicts, predictable CSS. Każda klasa atomowa. Maintainable w dużych projektach;BEM naming convention została deprecated w favor of CSS Modules. Modern React/Angular projects używają scoped styles zamiast BEM. Manual class naming jest anti-pattern w 2024;BEM methodology działa tylko z SASS preprocessor - vanilla CSS nie wspiera BEM syntax. Wymaga compilation step przez SASS compiler dla proper class name resolution;1
