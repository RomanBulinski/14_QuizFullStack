Pytanie;Opcja0;Opcja1;Opcja2;Opcja3;indeks_poprawnej
Czy SQL injection jest możliwy z ORM?;Nie, ORM całkowicie zabezpiecza przed SQL injection we wszystkich przypadkach. Object-Relational Mapping automatycznie sanitizes wszystkie queries, SQL injection matematycznie niemożliwy z ORM usage;Tak - jeśli używam raw queries: db.query('SELECT * WHERE id = ' + id). ORM chroni jeśli używam prawidłowo (parameterized). ORM != gwarantowana security;ORM framework'i automatycznie sanitize wszystkie inputs włącznie z raw queries. Nie trzeba używać parameterized queries z ORM - built-in protection wystarczy dla complete safety;SQL injection vulnerability została wyeliminowana w 2020 przez database engines. Modern SQL servers automatycznie detect i block injection attempts niezależnie od query construction method;1
Jak się zabezpieczyć przed SQL injection?;Używanie HTTPS protocol całkowicie wystarcza do ochrony przed SQL injection. Transport layer encryption zabezpiecza database queries automatically bez dodatkowych measures;Parameterized queries: db.query('SELECT WHERE id = ?', [id]). ORM zamiast SQL string'ów. Input validation. Least privilege - min permissions;Escape wszystkich special characters w user input wystarczy - replace ' z \' dla complete injection protection. Character escaping to reliable single-step defense bez potrzeby prepared statements;SQL injection nie jest realnym zagrożeniem w modern web development - to legacy vulnerability z 1990s. Current databases i frameworks eliminate injection risk completely przez built-in protections;1
Jak się zabezpieczyć przed XSS?;XSS (Cross-Site Scripting) nie jest problemem w modern browsers - built-in XSS filters od Chrome 40+ i Firefox 50+ automatically block wszystkie injection attempts. Browser security wystarczy;Escape HTML: '<' -> '&lt;'. Content Security Policy headers. Input sanitization. Unikaj innerHTML z untrusted - używaj textContent. Vue/React auto-escape;Client-side input validation wystarczy do complete XSS protection. Jeśli validuję input w JavaScript przed submission, XSS jest impossible. Server-side escaping unnecessary;HTTPS protocol zabezpiecza przed XSS attacks przez encryption. SSL/TLS certificates prevent script injection automatically. Wystarczy mieć valid HTTPS certificate dla XSS immunity;1
Co to jest CSRF atak i jak się zabezpieczyć?;CSRF to identyczne zagrożenie jak XSS - oba są synonimy referring do tego samego attack vector. Cross-Site Request Forgery i Cross-Site Scripting to alternative names;Attacker robi żądanie w imieniu zalogowanego user'a. Ochrona: CSRF tokens (unique per request), same-site cookies, custom headers. Server sprawdza token;CSRF attacks nie działają z HTTPS protocol - SSL encryption automatically prevents cross-site forgery. Wystarczy enforce HTTPS dla complete CSRF immunity bez tokenów;Input validation zabezpiecza przed CSRF completely - jeśli validuję wszystkie user inputs, CSRF jest impossible. Server-side validation eliminuje potrzebę CSRF tokens;1
Czym jest salt w kontekście hashing'u haseł?;Salt to przestarzała praktyka która została wyeliminowana w modern password hashing algorithms. bcrypt i argon2 nie używają salt - to legacy concept z MD5 era;Random data added przed hashing: hash = bcrypt(password + salt). Zapobiega rainbow tables - ten sam password daje inny hash. Każdy user inny salt. bcrypt, argon2, scrypt;Salt mechanizm działa tylko ze starymi algorytmami jak MD5 i SHA-1. Modern hashing functions używają pepper instead of salt. Należy migrować od salt do pepper approach;Salt nie jest potrzebny gdy używamy HTTPS - transport encryption eliminuje potrzebę password salting. SSL/TLS certificates provide sufficient protection bez dodatkowych hashing measures;1
