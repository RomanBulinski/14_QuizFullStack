Pytanie;Opcja0;Opcja1;Opcja2;Opcja3;indeks_poprawnej
Czy SQL injection jest możliwy z ORM?;Nie, ORM całkowicie zabezpiecza;Tak - jeśli używam raw queries: db.query('SELECT * WHERE id = ' + id). ORM chroni jeśli używam prawidłowo (parameterized). ORM != gwarantowana security;ORM automatycznie sanitize wszystko;SQL injection nie istnieje od 2020;1
Jak się zabezpieczyć przed SQL injection?;Tylko używanie HTTPS wystarcza;Parameterized queries: db.query('SELECT WHERE id = ?', [id]). ORM zamiast SQL string'ów. Input validation. Least privilege - min permissions;Escape wszystkich znaków specjalnych;SQL injection nie jest realnym zagrożeniem;1
Jak się zabezpieczyć przed XSS?;XSS nie jest problemem w modern browsers;Escape HTML: '<' -> '&lt;'. Content Security Policy headers. Input sanitization. Unikaj innerHTML z untrusted - używaj textContent. Vue/React auto-escape;Wystarczy walidacja po stronie klienta;HTTPS zabezpiecza przed XSS;1
Co to jest CSRF atak i jak się zabezpieczyć?;CSRF to to samo co XSS;Attacker robi żądanie w imieniu zalogowanego user'a. Ochrona: CSRF tokens (unique per request), same-site cookies, custom headers. Server sprawdza token;CSRF nie działa z HTTPS;Walidacja input'u zabezpiecza przed CSRF;1
Czym jest salt w kontekście hashing'u haseł?;Salt to przestarzała praktyka;Random data added przed hashing: hash = bcrypt(password + salt). Zapobiega rainbow tables - ten sam password daje inny hash. Każdy user inny salt. bcrypt, argon2, scrypt;Salt to tylko dla starych algorytmów MD5;Salt nie jest potrzebny z HTTPS;1
