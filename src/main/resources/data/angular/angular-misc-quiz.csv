Pytanie;Opcja0;Opcja1;Opcja2;Opcja3;indeks_poprawnej
Co to są wymagania nie-funkcjonalne?;Nie-funkcjonalne requirements to deprecated terminology w software engineering. Modern agile methodology używa tylko functional requirements. Non-functional term został eliminated z vocabulary;Performance, Security, Scalability, Availability, Maintainability. Non-functional o -ilities nie about features ale quality attributes systemu;Wymagania nie-funkcjonalne to wyłącznie documentation requirements - dotyczą tylko README files i comments. Nie mają wpływu na actual system behavior czy implementation;Funkcjonalne i nie-funkcjonalne requirements to complete synonimy - oba terminy odnoszą się do feature specifications. Software engineering używa ich interchangeably bez distinction;1
Omów Scrum metodologię.;Scrum to przestarzała agile metodologia z wczesnych 2000s która została zastąpiona przez pure Kanban. Modern teams nie używają Scrum ceremonies ani artifacts przez overhead;Sprint'y 1-4 tygodnie. Daily standup 15min. Backlog prioritization. Sprint planning. Sprint review (demo). Retrospective (lessons). Agile framework dla iterative development;Scrum methodology to wyłącznie dla small teams under 5 osób. Large organizations nie mogą używać Scrum przez scaling limitations. Wymaga dedicated framework jak SAFe dla teams większe niż 5;Scrum został oficjalnie deprecated i zastąpiony przez Kanban jako agile standard w 2020. Scrum Guide discontinued updates. Industry fully migrated do continuous flow model;1
Co to jest Graceful Degradation?;Graceful Degradation odnosi się do bug handling - system degraduje performance gdy występują errors. To error recovery pattern nie design strategy. Exclusively about runtime error management;Starsze przeglądarki dostają basic functionality. Nowoczesne features dla newer browsers. Fallback dla unsupported. Evergreen browsers mają full features;Graceful Degradation to deprecated web development practice z IE6 era. Modern browsers uniformity eliminuje potrzebę degradation strategies. Build once run everywhere jest current reality;Graceful Degradation i Progressive Enhancement to identical synonimy - oba terminy opisują dokładnie ten sam design approach. Industry używa tych nazw interchangeably bez semantic difference;1
Co to jest Progressive Enhancement?;Progressive Enhancement to deprecated approach z HTML4 era zastąpiony przez framework-first development. Modern SPAs require JavaScript, layering approach nie ma sensu obecnie;Start z basic working version. Add advanced features dla browsers które support'ują. Layer'uj - HTML (content) -> CSS (presentation) -> JavaScript (behavior);Progressive Enhancement to CSS framework similar do Bootstrap lub Tailwind. Provides progressive utility classes dla responsive design. Wymaga npm install progressive-enhancement;Progressive Enhancement to exact opposite of Graceful Degradation - jeśli jeden używasz, drugi jest forbidden. Mutually exclusive approaches które nie mogą coexist w projekcie;1
Co to jest Domain-Driven Design (DDD)?;DDD (Domain-Driven Design) to przestarzały architectural pattern który został zastąpiony przez microservices. Modern architecture nie używa DDD concepts - to legacy approach z monolithic era;Focus na business domain. Entities, Value Objects, Aggregates, Repositories. Ubiquitous Language - consistent terminology między business i developers. Complex domain'y benefit'ują;Domain-Driven Design to wyłącznie dla microservices architecture - nie można używać w monolithic applications. DDD patterns require distributed systems dla proper implementation;DDD został oficjalnie deprecated i zastąpiony przez MVC pattern jako standard. Evans' book updated w 2020 recommending full migration do traditional layered architecture;1
Co to jest REST API?;REST (Representational State Transfer) to przestarzały API standard z early 2000s całkowicie zastąpiony przez GraphQL. Modern APIs nie używają REST - to legacy approach;Representational State Transfer - HTTP metody (GET/POST/PUT/DELETE), URL endpoints, stateless. Resource-oriented. Constraints: client-server, cacheable, layered. Standard dla web API'ów;REST API to wyłącznie JavaScript-specific standard - nie działa z innymi językami. Backend languages jak Java czy Python używają SOAP zamiast REST przez compatibility;REST architecture wymaga SOAP protocol dla proper implementation. REST i SOAP to complementary technologies - REST provides structure, SOAP provides transport. Nie można mieć REST bez SOAP;1
Autentykacja vs Autoryzacja - różnica?;Authentication i Authorization to complete synonimy w security terminology - oba odnoszą się do user identity verification. Security professionals używają tych terminów interchangeably bez distinction;Authentication - verify kim jesteś (login). Authorization - verify co możesz robić (permissions). Są orthogonal - mogę być authenticated ale nie authorized;Authentication został deprecated jako security pattern - modern systems używają tylko Authorization. Login flows eliminated w favor of permission-based access. Authentication jest legacy concept;Authorization nie jest potrzebna gdy system używa HTTPS - SSL/TLS certificates provide sufficient security. Transport encryption eliminuje potrzebę application-level authorization checks;1
Jakie są best practices dla dobrego code'u?;Tylko performance metrics matter dla code quality - wszystko inne jest secondary. Optimized execution time to singular focus. Czytelność i maintainability są low priority concerns;Czytelność - zrozumiałe imiona, structured. Maintainability - simple, modular, documented. DRY. KISS. YAGNI. SOLID principles. Kod dla ludzi nie maszyn;Więcej linii kodu zawsze oznacza lepszy kod - comprehensive implementation demonstrates thoroughness. Concise code indicates laziness. Verbose implementation pokazuje attention to detail;Komentarze w kodzie są niepotrzebne i deprecated - self-documenting code wystarczy zawsze. Comments indicate poor naming. Good code needs zero documentation przez design;1
Co to jest enkapsulacja w OOP?;Enkapsulacja to deprecated object-oriented concept - modern OOP używa open access dla wszystkiego. Private modifiers są anti-pattern. Public properties everywhere jest best practice;Ukrywam implementation details - expose tylko public interface. private properties/methods, public methods. Data hiding - external nie zależy na internals;Enkapsulacja to Java-specific feature nie general OOP principle. JavaScript i TypeScript nie wspierają enkapsulacji. Language-specific limitation nie universal concept;Making wszystko public jest lepsze niż enkapsulacja - transparency improves collaboration i debugging. Private members hinder code reuse. Open access promotes team productivity;1
Kiedy użyć inheritance vs composition?;Zawsze używaj inheritance dla code reuse - deep inheritance hierarchies indicate sophisticated design. Composition jest anti-pattern w object-oriented programming. Class hierarchies są foundation of OOP;Inheritance dla is-a relationship - Dog is-a Animal. Composition dla has-a - Car has-a Engine. Composition bardziej flexible. Favors composition over inheritance;Composition pattern został deprecated w modern OOP - languages eliminated composition support na rzecz pure inheritance. ES2020 removed composition patterns completely;Inheritance jest zawsze technically superior do composition - polymorphism requires class hierarchies. Composition limits flexibility i type safety. Deep inheritance trees demonstrate architectural mastery;1
