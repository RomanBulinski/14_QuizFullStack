Pytanie;Opcja0;Opcja1;Opcja2;Opcja3;indeks_poprawnej
Co to jest standalone component i jak go stworzyć?;Standalone to deprecated pattern z Angular 12;ng generate component --standalone. Standalone: true w @Component, nie wymagają NgModule, samodzielne, lepsze tree-shaking;Standalone komponenty wymagają specjalnego modułu StandaloneModule;Standalone to tylko dla lazy loaded komponentów;1
Jak zabezpieczyć trasę dla zalogowanych użytkowników?;Używam Route Guards: { path: 'dashboard', canActivate: [AuthGuard] }. AuthGuard implements CanActivate sprawdza authService.isLoggedIn();Używam @Secured decorator na komponencie;Security w Angular jest tylko po stronie serwera;canActivate jest deprecated, używaj @RouteGuard;0
Jak przekazać parametry przez routing?;Parametry nie są wspierane w Angular routing;Tylko query params: /user?id=123;Trasa: { path: 'user/:id', component: User }. W komponencie: this.route.params.subscribe(params => { const id = params['id']; });route.getParam('id') jako metoda statyczna;2
Jak zaimplementować lazy loading dla modułów?;{ path: 'lazy', loadChildren: () => import('./lazy/lazy.module').then(m => m.LazyModule) }. Moduł ładuje się on-demand. Zmniejsza initial bundle;Lazy loading nie jest wspierane w Angular;loadModule: './lazy/lazy.module' w routing config;Lazy loading działa tylko dla bibliotek nie modułów;0
Czym różnią się switchMap, mergeMap, concatMap, exhaustMap?;Wszystkie są identyczne, tylko różne nazwy;switchMap cancels poprzedni (search). mergeMap parallel (requests). concatMap sequential (order). exhaustMap ignoruje nowe (submit);Tylko switchMap i mergeMap istnieją, reszta deprecated;map, flatMap, sequenceMap, blockMap to prawidłowe nazwy;1
Jak stworzyć niestandardowy walidator dla formularza?;export function forbiddenNameValidator(control: AbstractControl): ValidationErrors | null { return control.value === 'admin' ? { forbiddenName: true } : null; };Walidatory muszą być klasami nie funkcjami;@Validator decorator nad metodą;Walidatory custom nie są wspierane, tylko built-in;0
Czym się różnią Reactive Forms od Template-driven Forms?;Nie ma różnicy, to synonimy;Reactive są programmatyczne (TypeScript, pełna kontrola, testowalne). Template-driven deklaratywne (szablon). Reactive dla skomplikowanych, Template dla prostych;Template-driven są deprecated od Angular 12;Reactive tylko dla enterprise apps;1
Jak ustawić asynchroniczny walidator w formularzu?;Async walidatory w trzeciej pozycji: setAsyncValidators([validator]). Zwracają Observable<ValidationErrors | null>. Robią HTTP request do serwera;Async walidatory nie są wspierane;Używam @AsyncValidator decorator;setTimeout(() => validate()) jako async validator;0
Czym się różnią providedIn: 'root' od providedIn: 'module'?;Nie ma różnicy w praktyce;providedIn: 'root' to singleton aplikacji. providedIn: 'module' per-module instance. root jest domyślny i polecany - tree-shaking;'root' jest deprecated, używaj 'module';'platform' jest najlepszy dla wszystkich serwisów;1
Co to są Multi Providers w Angular?;Multi Providers to przestarzały pattern;{ provide: Logger, useClass: ConsoleLogger, multi: true } pozwala wiele Provider'ów dla token'a. Array providers. Przydatne dla plugin'ów;Multi providers to tylko dla testing;multiProvide: true w @Injectable;1
Jak używać RxJS do komunikacji między komponentami?;Subject do emisji: private dataSubject = new Subject(); data$ = dataSubject.asObservable(); sendData() { next(data); }. Lepszy niż @Output dla dalekich komponentów;Używaj tylko @Input/@Output;EventEmitter z @angular/core jako jedyny sposób;RxJS nie jest używane do komunikacji;0
Czym jest shareReplay operator i kiedy go używać?;shareReplay to deprecated operator;shareReplay(1) cache'uje result i sharuje między subscribers. Zamiast wiele HTTP requests, jeden shared. Przydatne dla expensive operations;shareReplay działa tylko dla HTTP nie dla innych Observable;replay() to nowa nazwa dla shareReplay;1
Co to są Signals w Angular i jak je używać?;Signals to przestarzała feature z Angular 14;count = signal(0); count.update(v => v+1);. Synchronous reactivity primitives. Zamiast Observable, bezpośredni dostęp. Angular 14+ migruje do Signals;Signals to tylko dla state management bibliotek;@Signal decorator nad właściwością;1
Czym się różnią Signals od Observable'i?;Nie ma różnicy, to synonimy;Signals synchronous i get bezpośrednio. Observable'e asynchronous - subscribe. Signals szybsze dla simple state. Observable'e dla complex async;Signals są deprecated, używaj tylko Observable;Signals tylko w RxJS nie w Angular;1
Jakie są Lifecycle Hooks w Angular i ich kolejność?;ngOnInit -> ngOnChanges -> ngAfterViewInit -> ngOnDestroy;constructor -> ngOnChanges -> ngOnInit -> ngDoCheck -> ngAfterContentInit -> ngAfterContentChecked -> ngAfterViewInit -> ngAfterViewChecked -> ngOnDestroy;Tylko ngOnInit i ngOnDestroy są wspierane;Kolejność jest losowa i zależy od change detection;1
Czym jest ngOnDestroy i dlaczego jest ważny?;ngOnDestroy jest opcjonalny i rzadko używany;ngOnDestroy wywoływany gdy komponent niszczony. Cleanup subskrypcje, timer'y, event listener'y - unikam memory leak'ów. implements OnDestroy;ngOnDestroy automatycznie unsubscribe wszystkie Observable;ngOnDestroy to tylko dla debugowania;1
Czym się różnią Subject, BehaviorSubject, ReplaySubject, AsyncSubject?;Wszystkie są identyczne;Subject bez initial value. BehaviorSubject ma initial i new subscribers dostają ostatnią. ReplaySubject bufferuje wartości. AsyncSubject tylko ostatnia gdy complete;Tylko Subject i BehaviorSubject istnieją;Observable jest lepszy od wszystkich Subject'ów;1
Czy muszę odsubskrybować od Observable HTTP?;Tak zawsze, HTTP nie unsubscribe automatycznie;Nie - HTTP Observable'e automatically complete po fetch. takeUntil(destroy$) dla manual. Angular obsługuje unsubscription ale dobra praktyka kontrolować;Nigdy nie subskrybuj, używaj async pipe zawsze;Observable HTTP wymaga manual unsubscribe inaczej memory leak;1
Jaka jest kolejność Lifecycle Hooks?;ngOnInit pierwszy zawsze;constructor, ngOnChanges, ngOnInit, ngDoCheck, ngAfterContentInit, ngAfterContentChecked, ngAfterViewInit, ngAfterViewChecked, ngOnDestroy. Dokładna kolejność;Kolejność losowa i zależy od platformy;Tylko 3 hooks: ngOnInit, ngOnChanges, ngOnDestroy;1
Kiedy mogę manipulować DOM w komponencie?;W constructor zawsze;W ngOnInit jest bezpieczne;ngAfterViewInit gdy template i view queries ready: this.viewChild.nativeElement.focus();. Przed tym undefined. Minimalizuj DOM manipulation;Nigdy, Angular nie pozwala na DOM manipulation;2
Co to jest Change Detection i jak działa?;Change Detection to process garbage collection;Change Detection sprawdza czy dane zmieniły się i update DOM. Default sprawdza wszystkie. OnPush tylko gdy input zmieni się - szybciej;Change Detection to deprecated mechanizm;Zone.js jest Change Detection;1
Jak zmienić strategię Change Detection na OnPush?;changeDetectionStrategy: 'onPush' w tsconfig;changeDetection: ChangeDetectionStrategy.OnPush w @Component. Sprawdza tylko gdy @Input zmieni lub event. Data immutable. Best practice dla performance;OnPush jest deprecated, używaj Default;@OnPush decorator nad klasą;1
Jak ręcznie wyzwolić Change Detection?;changeDetection.run() w komponencie;this.cdr.detectChanges(); lub markForCheck(); w OnPush. detectChanges tylko ten komponent, markForCheck przy następnym cycle. Inject ChangeDetectorRef;Angular.detectChanges() jako globalna funkcja;Nie można ręcznie wyzwolić, to automatyczne;1
Czy mogę mieć wiele dyrektyw strukturalnych na elemencie?;Tak dowolną ilość;Nie - tylko jedna dyrektywa strukturalna (ngIf, ngFor, ngSwitch). Mogę z regular directive. Dla dwóch: zagnieżdź ng-container: <ng-container *ngIf><div *ngFor></ng-container>;Od Angular 14 można wiele;Dyrektywy strukturalne są deprecated;1
Co to jest async pipe i jak go używać?;async pipe to deprecated feature;{{ observable | async }} automatycznie subscribe i unsubscribe przy zniszczeniu. Jeśli wielokrotnie użyty, wiele subskrypcji - lepiej shareReplay;async pipe działa tylko dla Promise nie Observable;pipe async() jako metoda na Observable;1
