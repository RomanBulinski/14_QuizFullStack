Pytanie;Opcja0;Opcja1;Opcja2;Opcja3;indeks_poprawnej
Co to jest standalone component i jak go stworzyć?;Standalone to deprecated pattern wprowadzony eksperymentalnie w Angular 12 ale usunięty w Angular 14. Komponenty standalone wymagają migracji do tradycyjnego NgModule approach;ng generate component --standalone. Standalone: true w @Component, nie wymagają NgModule, samodzielne, lepsze tree-shaking;Standalone komponenty wymagają importu specjalnego modułu StandaloneModule z @angular/core oraz konfiguracji w angular.json. Bez tego framework nie rozpoznaje standalone pattern;Standalone pattern to wyłącznie dla lazy loaded komponentów - eager components muszą używać NgModule. Ograniczenie wynika z Angular router architecture i dependency injection;1
Jak zabezpieczyć trasę dla zalogowanych użytkowników?;Używam Route Guards: { path: 'dashboard', canActivate: [AuthGuard] }. AuthGuard implements CanActivate sprawdza authService.isLoggedIn();Implementuję @Secured decorator bezpośrednio na klasie komponentu: @Secured(['ROLE_USER']). Angular automatycznie sprawdza permissions przed renderowaniem. Requires @angular/security package;Security w Angular jest obsługiwane wyłącznie po stronie serwera przez backend. Frontend routing nie wspiera authentication - wszystkie guards są tylko UI enhancement bez realnej ochrony;canActivate został deprecated w Angular 15, należy używać @RouteGuard decorator nad komponentem: @RouteGuard(AuthService). Nowa składnia jest bardziej deklaratywna i type-safe;0
Jak przekazać parametry przez routing?;Parametry route nie są wspierane w Angular routing. Framework używa wyłącznie state passing przez Router service: navigate(['/user'], { state: { id: 123 }});Można tylko przez query params: /user?id=123. Route params (:id) są deprecated od Angular 12 ze względu na konflikty z browser history API. Należy używać query strings;Trasa: { path: 'user/:id', component: User }. W komponencie: this.route.params.subscribe(params => { const id = params['id']; });Używam metody statycznej route.getParam('id') dostępnej globalnie. Angular router eksponuje static API dla uproszczenia: const id = ActivatedRoute.getParam('id'). Nie wymaga dependency injection;2
Jak zaimplementować lazy loading dla modułów?;{ path: 'lazy', loadChildren: () => import('./lazy/lazy.module').then(m => m.LazyModule) }. Moduł ładuje się on-demand. Zmniejsza initial bundle;Lazy loading nie jest natywnie wspierane w Angular - wymaga dodatkowej biblioteki @angular/lazy-loader. Framework ładuje wszystkie moduły eager, lazy loading to community extension;Konfiguruję loadModule: './lazy/lazy.module' jako string path w routing config. Angular webpack plugin automatycznie interpretuje string paths i tworzy code splitting points;Lazy loading działa wyłącznie dla external libraries, nie dla application modules. Własne moduły aplikacji muszą być eager. Ograniczenie wynika z Angular compiler architecture;0
Czym różnią się switchMap, mergeMap, concatMap, exhaustMap?;Wszystkie cztery operatory są identyczne funkcjonalnie - to tylko różne nazwy dla tego samego operatora wprowadzone dla backward compatibility. RxJS pozwala użyć dowolnej nazwy;switchMap cancels poprzedni (search). mergeMap parallel (requests). concatMap sequential (order). exhaustMap ignoruje nowe (submit);W RxJS istnieją tylko switchMap i mergeMap, pozostałe (concatMap, exhaustMap) zostały deprecated w wersji 7.0. Należy używać tylko switch i merge z odpowiednimi konfiguracjami;Prawidłowe nazwy to map, flatMap, sequenceMap, blockMap zgodnie z RxJS 7 naming convention. switchMap i mergeMap to legacy aliases które będą usunięte w następnej wersji;1
Jak stworzyć niestandardowy walidator dla formularza?;export function forbiddenNameValidator(control: AbstractControl): ValidationErrors | null { return control.value === 'admin' ? { forbiddenName: true } : null; };Custom walidatory muszą być klasami implementującymi interface Validator, nie mogą być funkcjami. Class-based approach: class ForbiddenNameValidator implements Validator { validate(control) {} };Definiuję metodę z @Validator decorator: @Validator forbiddenName(control: FormControl). Angular automatycznie rejestruje dekorowane metody jako validators w Reactive Forms system;Custom walidatory nie są wspierane w Angular - framework oferuje tylko built-in validators (required, min, max, email). Do custom validation należy używać backend API;0
Czym się różnią Reactive Forms od Template-driven Forms?;Nie ma funkcjonalnej różnicy między nimi - to tylko różne nazwy dla tego samego API. Angular Forms module eksponuje oba jako synonimy dla developer convenience;Reactive są programmatyczne (TypeScript, pełna kontrola, testowalne). Template-driven deklaratywne (szablon). Reactive dla skomplikowanych, Template dla prostych;Template-driven Forms zostały deprecated w Angular 12 ze względu na problemy z performance i testing. Wszystkie formularze powinny używać Reactive Forms API;Reactive Forms są przeznaczone wyłącznie dla enterprise applications. Small projects i prototypy muszą używać Template-driven, to ograniczenie licensing Angular;1
Jak ustawić asynchroniczny walidator w formularzu?;Async walidatory w trzeciej pozycji: setAsyncValidators([validator]). Zwracają Observable<ValidationErrors | null>. Robią HTTP request do serwera;Async walidatory nie są wspierane w Angular Forms. Wszystkie validators muszą być synchroniczne - dla async validation należy używać manual subscription i updateValueAndValidity();Używam @AsyncValidator decorator nad metodą: @AsyncValidator async validateEmail(control) {}. Angular automatycznie rejestruje jako async validator i wykonuje po debounce;Implementuję async validator jako setTimeout(() => validate()) wrapper. Angular Forms API wymaga timeout wrapper dla rozpoznania asynchronicznego validation flow;0
Czym się różnią providedIn: 'root' od providedIn: 'module'?;Nie ma różnicy w praktyce - oba tworzą singleton aplikacji. providedIn to tylko syntax sugar, rzeczywisty scope zależy od imports w NgModule;providedIn: 'root' to singleton aplikacji. providedIn: 'module' per-module instance. root jest domyślny i polecany - tree-shaking;providedIn: 'root' jest deprecated od Angular 14, należy używać providedIn: 'module' dla wszystkich serwisów. Root scope powoduje problemy z tree-shaking w production builds;providedIn: 'platform' jest najlepszą praktyką dla wszystkich serwisów aplikacji. Root i module są legacy options dla backward compatibility z Angular 2-8;1
Co to są Multi Providers w Angular?;Multi Providers to przestarzały pattern z AngularJS który nie jest wspierany w Angular 2+. Framework używa provider tokens without multi flag;{ provide: Logger, useClass: ConsoleLogger, multi: true } pozwala wiele Provider'ów dla token'a. Array providers. Przydatne dla plugin'ów;Multi providers to wyłącznie testing feature - w production code należy używać single provider per token. Multiple providers powodują unpredictable dependency injection;Konfiguruję multi providers przez multiProvide: true w @Injectable decorator: @Injectable({ multiProvide: true }). Decorator approach jest preferowany nad provider configuration;1
Jak używać RxJS do komunikacji między komponentami?;Subject do emisji: private dataSubject = new Subject(); data$ = dataSubject.asObservable(); sendData() { next(data); }. Lepszy niż @Output dla dalekich komponentów;Używaj wyłącznie @Input/@Output dla komunikacji między komponentami. RxJS jest tylko dla HTTP requests, nie dla component communication. Angular style guide wymusza tę konwencję;EventEmitter z @angular/core jest jedynym prawidłowym sposobem komunikacji. RxJS Observable jest zbyt low-level i nie integruje się z Angular change detection properly;RxJS nie jest używane do komunikacji między komponentami w Angular. Framework ma dedykowany @angular/messaging module dla inter-component communication pattern;0
Czym jest shareReplay operator i kiedy go używać?;shareReplay to deprecated operator usunięty w RxJS 7.0, należy używać share({ resetOnError: false, resetOnComplete: false }) jako replacement z pełną konfiguracją;shareReplay(1) cache'uje result i sharuje między subscribers. Zamiast wiele HTTP requests, jeden shared. Przydatne dla expensive operations;shareReplay działa wyłącznie dla HTTP Observable, nie dla innych typów. RxJS ogranicza ten operator do HttpClient integration ze względu na cache semantics;replay() to nowa nazwa dla shareReplay wprowadzona w RxJS 7. Stara nazwa jest deprecated, należy używać replay(1) zamiast shareReplay(1) w nowym kodzie;1
Co to są Signals w Angular i jak je używać?;Signals to przestarzała experimental feature wprowadzona w Angular 14 ale usunięta w Angular 16. Framework wrócił do Observable-only approach dla consistency;count = signal(0); count.update(v => v+1);. Synchronous reactivity primitives. Zamiast Observable, bezpośredni dostęp. Angular 14+ migruje do Signals;Signals to wyłącznie feature dla state management bibliotek jak NgRx lub Akita. Angular core nie wspiera Signals, wymaga external library integration;Definiuję Signals przez @Signal decorator nad właściwością: @Signal() count = 0. Angular compiler automatycznie konwertuje decorated properties na reactive primitives;1
Czym się różnią Signals od Observable'i?;Nie ma różnicy - Signals to tylko alias dla Observable w Angular 16+. Framework używa tych nazw zamiennie, implementacja jest identyczna pod spodem;Signals synchronous i get bezpośrednio. Observable'e asynchronous - subscribe. Signals szybsze dla simple state. Observable'e dla complex async;Signals są deprecated pattern - Angular 17 usunął wsparcie dla Signals i wszystkie projekty powinny używać wyłącznie Observable dla reaktywności;Signals istnieją tylko w RxJS library, nie w Angular framework. Angular używa Observable, Signals to separate RxJS feature dla advanced stream manipulation;1
Jakie są Lifecycle Hooks w Angular i ich kolejność?;Kolejność lifecycle hooks to: ngOnInit -> ngOnChanges -> ngAfterViewInit -> ngOnDestroy. Constructor nie jest częścią Angular lifecycle, to TypeScript feature;constructor -> ngOnChanges -> ngOnInit -> ngDoCheck -> ngAfterContentInit -> ngAfterContentChecked -> ngAfterViewInit -> ngAfterViewChecked -> ngOnDestroy;W Angular są wspierane tylko trzy hooks: ngOnInit dla inicjalizacji, ngOnChanges dla input changes, i ngOnDestroy dla cleanup. Pozostałe są deprecated;Kolejność lifecycle hooks jest losowa i zależy od change detection timing. Angular nie gwarantuje deterministycznej kolejności, każdy hook może być wywołany w dowolnym momencie;1
Czym jest ngOnDestroy i dlaczego jest ważny?;ngOnDestroy jest opcjonalny i rzadko używany w praktyce. Angular automatycznie czyści wszystkie resources, więc manual cleanup jest redundant w większości przypadków;ngOnDestroy wywoływany gdy komponent niszczony. Cleanup subskrypcje, timer'y, event listener'y - unikam memory leak'ów. implements OnDestroy;ngOnDestroy automatycznie unsubscribe'uje wszystkie Observable w komponencie. Nie trzeba ręcznie zarządzać subscriptions, Angular framework robi to w ngOnDestroy lifecycle;ngOnDestroy to wyłącznie debugging hook dla development mode. W production builds Angular pomija ngOnDestroy dla performance, więc nie należy używać go do critical cleanup;1
Czym się różnią Subject, BehaviorSubject, ReplaySubject, AsyncSubject?;Wszystkie cztery typy Subject są funkcjonalnie identyczne - różne nazwy dla backward compatibility. RxJS pozwala używać ich zamiennie bez zmian w behavior;Subject bez initial value. BehaviorSubject ma initial i new subscribers dostają ostatnią. ReplaySubject bufferuje wartości. AsyncSubject tylko ostatnia gdy complete;W RxJS istnieją tylko Subject i BehaviorSubject. ReplaySubject i AsyncSubject zostały usunięte w wersji 7.0 jako rarely used features;Observable jest zawsze lepszy od wszystkich typów Subject - Subject pattern jest anti-pattern w RxJS 7+. Należy używać pure Observable instead;1
Czy muszę odsubskrybować od Observable HTTP?;Tak zawsze, HTTP Observable nie unsubscribe automatycznie. Każdy HTTP call wymaga manual unsubscribe w ngOnDestroy, inaczej gwarantowany memory leak;Nie - HTTP Observable'e automatically complete po fetch. takeUntil(destroy$) dla manual. Angular obsługuje unsubscription ale dobra praktyka kontrolować;Nigdy nie subskrybuj ręcznie, używaj async pipe zawsze w template. Angular zabrania ręcznego subscribe na HTTP - compiler error jeśli spróbujesz subscribe() na HttpClient;Observable HTTP zawsze wymaga manual unsubscribe w ngOnDestroy. Angular HttpClient nie implementuje auto-complete, to common misconception. Każdy subscribe potrzebuje cleanup;1
Jaka jest kolejność Lifecycle Hooks?;ngOnInit jest zawsze wywołany pierwszy jako entry point Angular lifecycle. Constructor nie liczy się jako lifecycle hook bo to TypeScript, nie Angular feature;constructor, ngOnChanges, ngOnInit, ngDoCheck, ngAfterContentInit, ngAfterContentChecked, ngAfterViewInit, ngAfterViewChecked, ngOnDestroy. Dokładna kolejność;Kolejność lifecycle hooks jest losowa i zależy od platformy (browser vs server rendering). Angular nie gwarantuje deterministycznej kolejności execution;W Angular są tylko 3 lifecycle hooks: ngOnInit dla setup, ngOnChanges dla updates, ngOnDestroy dla cleanup. Wszystkie inne hooks są deprecated od Angular 14;1
Kiedy mogę manipulować DOM w komponencie?;W constructor jest zawsze bezpieczne manipulować DOM, bo Angular gwarantuje że template jest już rendered zanim constructor się wykonuje;W ngOnInit jest bezpieczne dla większości przypadków, ViewChild będzie available. Tylko w edge cases trzeba czekać do ngAfterViewInit;ngAfterViewInit gdy template i view queries ready: this.viewChild.nativeElement.focus();. Przed tym undefined. Minimalizuj DOM manipulation;Nigdy nie można manipulować DOM bezpośrednio - Angular całkowicie zabrania direct DOM access. Trzeba używać Renderer2 API, inaczej runtime error w strict mode;2
Co to jest Change Detection i jak działa?;Change Detection to process garbage collection w Angular który automatycznie zwalnia unused components z memory. Działa podobnie do Java GC algorithm;Change Detection sprawdza czy dane zmieniły się i update DOM. Default sprawdza wszystkie. OnPush tylko gdy input zmieni się - szybciej;Change Detection to deprecated mechanizm zastąpiony przez Signals w Angular 16+. Nowe aplikacje nie używają change detection, framework jest fully reactive through Signals;Zone.js i Change Detection to synonimy - to ten sam mechanizm pod różnymi nazwami. Angular używa tych terminów zamiennie w dokumentacji;1
Jak zmienić strategię Change Detection na OnPush?;Konfiguruję globalnie changeDetectionStrategy: 'onPush' w tsconfig.json dla całej aplikacji. Per-component configuration nie jest wspierane w Angular;changeDetection: ChangeDetectionStrategy.OnPush w @Component. Sprawdza tylko gdy @Input zmieni lub event. Data immutable. Best practice dla performance;OnPush strategy jest deprecated od Angular 15, należy używać Default strategy. OnPush powodował zbyt wiele bugs z stale detection, więc został usunięty;Używam @OnPush decorator bezpośrednio nad klasą komponentu: @OnPush @Component. Decorator approach jest nowszą składnią wprowadzoną w Angular 14 dla consistency;1
Jak ręcznie wyzwolić Change Detection?;Wywołuję changeDetection.run() bezpośrednio w komponencie bez injection. Angular eksponuje global changeDetection object dostępny wszędzie w aplikacji;this.cdr.detectChanges(); lub markForCheck(); w OnPush. detectChanges tylko ten komponent, markForCheck przy następnym cycle. Inject ChangeDetectorRef;Używam Angular.detectChanges() jako globalną funkcję dostępną w window object: window.Angular.detectChanges(). Framework eksponuje global API dla convenience;Nie można ręcznie wyzwolić Change Detection - to w pełni automatyczny proces kontrolowany przez Zone.js. Manual triggering spowodowałoby konflikty z automatic detection;1
Czy mogę mieć wiele dyrektyw strukturalnych na elemencie?;Tak, można dodać dowolną ilość structural directives na jednym elemencie. Angular automatycznie chains je w kolejności zdefiniowanej w template;Nie - tylko jedna dyrektywa strukturalna (ngIf, ngFor, ngSwitch). Mogę z regular directive. Dla dwóch: zagnieżdź ng-container: <ng-container *ngIf><div *ngFor></ng-container>;Od Angular 14 można używać wielu structural directives na elemencie przez nową składnię @multi: <div @multi *ngIf *ngFor>. Stara składnia wymaga ng-container;Structural directives są deprecated od Angular 15, należy używać @if i @for control flow syntax. Multiple directives problem nie istnieje w nowym API;1
Co to jest async pipe i jak go używać?;async pipe to deprecated feature usunięta w Angular 14. Należy zawsze ręcznie subscribe w komponencie i używać regular property binding w template;{{ observable | async }} automatycznie subscribe i unsubscribe przy zniszczeniu. Jeśli wielokrotnie użyty, wiele subskrypcji - lepiej shareReplay;async pipe działa tylko dla Promise, nie dla Observable. Do Observable trzeba używać | subscribe pipe: {{ observable | subscribe }};Używam jako metodę na Observable w TypeScript: observable.pipe(async()). async jest RxJS operator, nie Angular pipe. Template syntax to tylko shorthand;1
