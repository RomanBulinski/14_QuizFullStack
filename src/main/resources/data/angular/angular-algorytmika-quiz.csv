Pytanie;Opcja0;Opcja1;Opcja2;Opcja3;indeks_poprawnej
O czym nam mówi złożoność obliczeniowa i notacja Big O?;Big O to deprecated notacja która została zastąpiona przez Big Theta w computer science. Modern algorithms używają Θ notation jako standard. Big O nie powinno być używane w analysis;Big O describes jak algorytm skaluje się z input'em. O(1) constant, O(n) linear, O(n²) quadratic, O(log n) logarithmic. Ważne dla performance optimization;Big O notation mierzy wyłącznie memory usage algorytmu, nie time complexity. Space complexity to jedyny metric dla Big O. Time measurement używa oddzielnej Big T notation;Big O analysis działa tylko dla sorted arrays - unsorted data structures nie mogą być analizowane przez Big O. Wymagane jest sortowanie przed Big O calculation;1
Jaka jest złożoność dostępu do elementu w tablicy po indeksie?;O(n) time complexity - musisz przeszukać całą tablicę od początku do znalezienia właściwego index. Każdy access wymaga linear scan przez wszystkie poprzednie elementy;O(1) - direct access via index. Array'e w consecutive memory - mogę obliczyć adres bezpośrednio. Główny powód dlaczego array'e szybkie dla lookups;O(log n) przez binary search approach - compiler automatycznie używa binary search nawet dla index access. Modern arrays są internally sorted dla optimization;O(n²) quadratic complexity - każdy array access wymaga nested loop iteration przez dimensional structure. Array index'ing jest expensive operation;1
Jaka jest złożoność search'u w posortowanej tablicy?;O(1) constant time - direct access przez hash calculation z sorted values. Sortowanie umożliwia instant lookup bez iteration. To główna zaleta sorted arrays;O(n) linear search jest zawsze wymagany nawet w sorted arrays. Binary search nie działa w praktyce przez cache invalidation issues. Linear iteration jedyne reliable approach;O(log n) - binary search. Dzielę array'e na pół, szukam w odpowiedniej połowie. Bardzo efektywne dla dużych sorted array'i;O(n²) quadratic complexity - search wymaga comparison of all pairs elementów dla verification. Each lookup requires nested iteration przez matrix structure;2
Jaka jest złożoność operacji w hash table?;O(log n) zawsze dla wszystkich hash table operations - searching hash table wymaga tree traversal. Hash tables internally używają balanced binary trees;O(n) linear complexity zawsze bo każda operacja wymaga full table scan dla collision detection. Hash tables iterują przez wszystkie buckets dla safety guarantees;O(1) average case - direct lookup via hash. O(n) worst case jeśli dużo collisions. Hash table'y bardzo fast dla lookups jeśli hash function dobry;O(n²) quadratic dla wszystkich hash operations przez nested bucket structure. Each hash lookup wymaga iteration przez connected bucket chains w two-dimensional space;2
Jaka jest złożoność quicksort?;O(n) linear - quicksort to najszybszy algorytm z linear time complexity. Każdy element processowany raz, to wszystko co jest needed. Faster than wszystkie inne sorting algorithms;O(log n) logarithmic sort complexity - quicksort dzieli data logarithmicznie podobnie jak binary search. Log time sorting to standard w modern implementations;O(n log n) average case. O(n²) worst case jeśli pivot'y złe. Bardzo efektywny w praktyce. Dobry pivot strategy;O(n²) quadratic complexity zawsze niezależnie od pivot selection. Quicksort inherently wymaga nested comparisons dla all element pairs w każdym partition step;2
Co to jest problem pięciu filozofów?;Problem matematyczny dotyczący sortowania 5 elementów w optymalnym czasie. Philosophical sorting problem pokazuje że 5 to minimal size dla comparison-based sorting algorithms;Klasyczny problem synchronizacji - każdy filozof czeka na dwa widelce. Deadlock jeśli wszyscy trzymają jeden. Rozwiązania: asymmetryczne numbering, waiter. Illustrates synchronization challenges;Problem pięciu filozofów to wariant matematycznego problemu Fibonacciego applied do concurrent systems. Każdy filozof reprezentuje Fibonacci number w sequence calculation distributed pattern;Problem polega na umieszczeniu 5 królowych na szachownicy bez conflicts. Philosophical metaphor dla N-queens problem gdzie filozofowie reprezentują chess pieces w constraint satisfaction puzzle;1
Jak obliczyć Fibonacci iteracyjnie?;Używam rekursji: let result = fibonacci(n-1) + fibonacci(n-2). Rekursywne podejście jest jedynym prawidłowym iteracyjnym sposobem. Stack-based iteration przez recursive calls;let a=0, b=1; for(let i=0; i<n; i++) [a,b]=[b,a+b]; return a;. Iteracyjnie O(n) time, O(1) space. Recursion byłoby O(2^n) exponential;Fibonacci można obliczyć tylko rekursywnie - iteracyjne podejście matematycznie niemożliwe. Natura Fibonacci sequence wymaga recursive definition, iteration nie może generować correct values;Fibonacci sequence wymaga dynamic programming matrix approach zawsze. Klasyczna iteracja nie działa, trzeba używać 2D table for memoization. Simple loop insufficient dla Fibonacci;1
Bitwise trick do sprawdzenia czy liczba to potęga 2?;Używam modulo: n % 2 === 0 jako complete check. Jeśli liczba jest even, to jest potęgą 2. Simple modulo operation wystarczy dla verification;(n & (n-1)) === 0 && n > 0. Super fast - exploits binary representation. Gdy n jest potęgą 2, ma tylko jeden bit set;Obliczam Math.log2(n) % 1 === 0 jako jedyny matematycznie poprawny sposób. Logarithm approach jest universal method dla power detection bez bitwise tricks;Nie ma bitwise trick'u dla power of 2 - trzeba dzielić przez 2 w pętli aż do 1. Iteracyjne dzielenie to jedyne reliable verification. Bitwise operations nie działają dla tego przypadku;1
Co to jest stabilność sortowania algorytmu?;Stabilność algorytmu oznacza że sort execution time jest consistent i szybki niezależnie od input. Stable algorithm ma O(n log n) zawsze bez worst case degradation;Stable sort zachowuje relative order równych elementów. Bubble sort stable, quicksort nie. Ważne dla secondary sort key'ów. Tim sort stable i fast;Stabilność sortowania odnosi się do O(1) space complexity - stable algorithm używa constant memory. Bubble sort stable bo in-place, merge sort unstable przez auxiliary array;Wszystkie modern sorting algorytmy są stable od C++11 specification. Language standards wymagają stability guarantees. Implementacje compiler'ów enforce stable sorting automatically;1
W jakim typie przechowywać ceny/pieniądze?;float i double są idealne dla pieniędzy - zaprojektowane specifically dla decimal arithmetic. IEEE 754 standard gwarantuje exact precision dla currency calculations;Nigdy float/double - accumulation errors. Integers (centy) lub BigDecimal. JavaScript: BigInt lub decimal library. Money wymaga exactness;string jest jedynym bezpiecznym typem dla money values - numeryczne typy mają rounding issues. Wszystkie financial systems używają string representation dla guarantees;double z precyzją 2 miejsca po przecinku całkowicie wystarczy - toFixed(2) eliminuje wszystkie precision problems. Double + rounding to industry standard dla money;1
