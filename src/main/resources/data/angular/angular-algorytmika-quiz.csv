Pytanie;Opcja0;Opcja1;Opcja2;Opcja3;indeks_poprawnej
O czym nam mówi złożoność obliczeniowa i notacja Big O?;Big O to deprecated notacja;Big O describes jak algorytm skaluje się z input'em. O(1) constant, O(n) linear, O(n²) quadratic, O(log n) logarithmic. Ważne dla performance optimization;Big O mierzy tylko memory usage nie time;Big O to tylko dla sorted arrays;1
Jaka jest złożoność dostępu do elementu w tablicy po indeksie?;O(n) - musisz przeszukać całą tablicę;O(1) - direct access via index. Array'e w consecutive memory - mogę obliczyć adres bezpośrednio. Główny powód dlaczego array'e szybkie dla lookups;O(log n) - binary search;O(n²) - nested loop required;1
Jaka jest złożoność search'u w posortowanej tablicy?;O(1) - direct access;O(n) - linear search zawsze;O(log n) - binary search. Dzielę array'e na pół, szukam w odpowiedniej połowie. Bardzo efektywne dla dużych sorted array'i;O(n²) - comparison of all pairs;2
Jaka jest złożoność operacji w hash table?;O(log n) zawsze;O(n) zawsze;O(1) average case - direct lookup via hash. O(n) worst case jeśli dużo collisions. Hash table'y bardzo fast dla lookups jeśli hash function dobry;O(n²) dla wszystkich operacji;2
Jaka jest złożoność quicksort?;O(n) zawsze najszybszy;O(log n) logarithmic sort;O(n log n) average case. O(n²) worst case jeśli pivot'y złe. Bardzo efektywny w praktyce. Dobry pivot strategy;O(n²) zawsze;2
Co to jest problem pięciu filozofów?;Problem sortowania 5 elementów;Klasyczny problem synchronizacji - każdy filozof czeka na dwa widelce. Deadlock jeśli wszyscy trzymają jeden. Rozwiązania: asymmetryczne numbering, waiter. Illustrates synchronization challenges;Problem matematyczny Fibonacciego;Problem z 5 królowymi na szachownicy;1
Jak obliczyć Fibonacci iteracyjnie?;let result = fibonacci(n-1) + fibonacci(n-2) rekursywnie;let a=0, b=1; for(let i=0; i<n; i++) [a,b]=[b,a+b]; return a;. Iteracyjnie O(n) time, O(1) space. Recursion byłoby O(2^n) exponential;Fibonacci można tylko rekursywnie;Fibonacci wymaga dynamic programming zawsze;1
Bitwise trick do sprawdzenia czy liczba to potęga 2?;n % 2 === 0 jako sprawdzenie;(n & (n-1)) === 0 && n > 0. Super fast - exploits binary representation. Gdy n jest potęgą 2, ma tylko jeden bit set;Math.log2(n) % 1 === 0 jako jedyny sposób;Nie ma trick'u, trzeba dzielić w pętli;1
Co to jest stabilność sortowania algorytmu?;Stabilność oznacza że sort jest szybki;Stable sort zachowuje relative order równych elementów. Bubble sort stable, quicksort nie. Ważne dla secondary sort key'ów. Tim sort stable i fast;Stabilność to O(1) space complexity;Wszystkie algorytmy są stable od C++11;1
W jakim typie przechowywać ceny/pieniądze?;float/double są idealne dla pieniędzy;Nigdy float/double - accumulation errors. Integers (centy) lub BigDecimal. JavaScript: BigInt lub decimal library. Money wymaga exactness;string jako jedyny bezpieczny typ;double z 2 miejscami po przecinku wystarczy;1
