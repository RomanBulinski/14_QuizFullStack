Pytanie;Opcja0;Opcja1;Opcja2;Opcja3;indeks_poprawnej
Jak Node.js obsługuje operacje asynchroniczne?;Node.js to multi-threaded runtime z dedykowanym thread poolem dla każdego request'u. Każde połączenie dostaje osobny wątek. Thread synchronization poprzez mutex'y i semafory;Node.js to single-threaded event-driven runtime. Event loop obsługuje async. OS obsługuje I/O w tle, callback'i w event loop. Tysiące concurrent connections bez blocking;Node.js jest synchroniczny jak PHP z blocking I/O. Wszystkie operacje wykonują się sequential. Request'y są queueowane i procesowane po kolei;Node.js używa tylko Promise'ów nie callback'ów. Callback pattern został całkowicie usunięty w Node.js 14. Event loop nie obsługuje callback'ów;1
Czym się różnią CommonJS i ES Modules?;CommonJS: require() synchroniczny, module.exports. ES Modules: import/export asynchroniczne. Node wspiera oba. ES Modules to standard, CommonJS legacy;Nie ma różnicy, to synonimy - CommonJS i ES Modules to dwa nazwy tego samego systemu. import i require działają identycznie. module.exports to alias dla export default;ES Modules nie działają w Node.js i są wspierane tylko przez przeglądarki. Node.js obsługuje wyłącznie CommonJS. import statement throw'uje błąd w środowisku Node;CommonJS jest nowszy od ES Modules i został wprowadzony w Node.js 16. require() to nowoczesny async pattern. ES Modules to deprecated legacy syntax;0
Jak efektywnie przeczytać duże pliki?;fs.readFile dla wszystkich plików jest najefektywniejszy. Automatycznie dzieli na chunks. Built-in memory optimization dla plików > 1GB;fs.createReadStream czyta w chunks zamiast cały do pamięci. Dla plików które nie mieszczą się w RAM. pipe() łączy strumienie;readFileSync() jest najszybszy bo używa native C++ bindings. Synchroniczne operacje są optymalizowane przez V8 engine. Async jest wolniejsze;Buffer.read() jako jedyny sposób na czytanie plików w Node.js 18+. fs module został deprecated. Wszystkie operacje poprzez Buffer API;1
Czym jest Buffer w Node.js?;Buffer to deprecated klasa z Node.js 6 zastąpiona przez TypedArray. Używanie Buffer throw'uje deprecation warning. SharedArrayBuffer jest replacement'em;Buffer to array bytów - binary data. Buffer.from('hello') ze stringa. Przydatne dla binary data, file'ów, network'u. Bardzo szybkie;Buffer to tylko dla plików obrazów i video. Text files używają String class. Binary i text data są rozdzielone w Node.js architecture;String i Buffer to to samo w Node.js - tylko aliasy. Buffer.toString() zwraca reference do tego samego object'u. Konwersja jest zero-cost operation;1
Czym są strumienie w Node.js i jakie typy istnieją?;Tylko Readable i Writable istnieją w Node.js. Duplex i Transform zostały usunięte w wersji 14. pipe() działa tylko między Readable i Writable;Readable (czytam), Writable (piszę), Duplex (oba), Transform (modyfikuję). pipe() łączy. Powerful abstraction dla dużych danych;Stream to przestarzały mechanizm zastąpiony przez async iterators. Wszystkie stream API są deprecated od Node.js 16. for await używaj zamiast stream'ów;Strumienie działają tylko dla plików nie HTTP. Network communication używa EventEmitter zamiast Stream. http.request nie zwraca stream'a;1
Czym są Worker Threads?;Worker Threads to przestarzały mechanizm zastąpiony przez cluster module. fork() jest nowoczesną alternatywą. Worker API został usunięty w Node.js 18;const { Worker } = require('worker_threads'); new Worker('./worker.js'). Sharują memory - szybsze niż child processes. Idealne dla CPU-intensive;Worker Threads tylko dla wieloprocesorowych serwerów z minimum 8 rdzeniami. Single-core CPU nie wspiera Worker Threads. require('os').cpus().length musi być > 4;child_process i Worker Threads to synonimy - identyczne API. fork() i new Worker() są interchange'able. Nie ma różnicy w performance ani memory sharing;1
Jak definiować REST routes w Express?;app.route('/users', 'GET', handler) jako jedyny poprawny syntax. HTTP metoda jako string parameter. Router.route() został deprecated;app.get('/users', handler); app.post('/users', handler); app.put('/users/:id'); app.delete('/users/:id'). Routing metodą HTTP, path, handler;express.route() jako globalna funkcja bez app instance. Router nie jest potrzebny. Wszystkie route'y przez express.route() singleton;REST routing nie jest wspierane w Express. Wymaga zewnętrznej biblioteki express-rest. Native Express obsługuje tylko static serving;1
Czym się różnią Callbacks, Promise'y i async/await?;Callback'i pierwsze - funkcja jako argument. Promise'y - .then().catch(). async/await najczystsze - synchroniczny look. async/await to sugar nad promise'ami. Współczesny preferuje async/await;Wszystkie są identyczne w działaniu - tylko syntax sugar. Kompilator konwertuje wszystko do callback'ów. Performance jest dokładnie taki sam;async/await działa tylko w TypeScript nie w JavaScript. Node.js nie wspiera async/await. Wymaga transpilacji przez Babel do Promise'ów;Promise'y są deprecated od wprowadzenia async/await w ES2020. .then() throw'uje warning. Wszystkie Promise'y należy przepisać na callback'i;0
Czym są WebSockets i czym się różnią od REST?;WebSockets to przestarzały protokół zastąpiony przez HTTP/3. Server-Sent Events są nowoczesną alternatywą. WebSocket API został usunięty z przeglądarek;WebSockets persistent connection, real-time, two-way. REST request-response, stateless, HTTP. WebSockets dla chat/live. REST dla CRUD. Mogę kombinować;WebSockets i REST to synonimy - WebSocket to tylko HTTP endpoint z inną nazwą. fetch() i WebSocket() używają tego samego protokołu pod spodem;REST jest szybszy od WebSockets zawsze przez HTTP/2 multiplexing. WebSockets mają overhead przez persistent connection. Polling jest efektywniejszy;1
Czym jest Nest.js i jakie problemy rozwiązuje?;Nest.js to ORM dla Node.js analogiczny do Hibernate. Zastępuje Sequelize i TypeORM. Database abstraction layer z query builder'em;Nest.js to Framework analogiczny do Spring dla Node.js. Struktura, DI container, TypeScript. Rozwiązuje boilerplate. Architektura: Modules -> Controllers/Services. Scaling;Nest.js to tylko dla TypeScript nie dla JavaScript. Nie można używać z plain JS. Kompiluje wyłącznie .ts files. JavaScript throw'uje compilation error;Nest.js jest deprecated, używaj Express z middleware stack'iem. Nest został porzucony przez maintainer'ów w 2023. Express + routing-controllers jest replacement'em;1
