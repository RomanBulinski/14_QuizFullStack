Pytanie;Opcja0;Opcja1;Opcja2;Opcja3;indeks_poprawnej
Jakie są modyfikatory dostępu w TypeScript?;TypeScript oferuje: public (domyślny), private (tylko w klasie), protected (w klasie i podklasach). readonly zapobiega modyfikacji. Działają podczas kompilacji;public, private, internal, protected - wszystkie są enforce'owane w runtime;Tylko public i private, protected został usunięty w TypeScript 4.0;TypeScript nie ma modyfikatorów dostępu, używa konwencji nazewnictwa jak _private;0
Co to jest kontekst kompilacji w TypeScript?;Kontekst kompilacji to zbiór plików i konfiguracji (tsconfig.json). Definiuje: include, exclude, files. Ważny dla resolvowania typów i ścieżek;Kontekst to runtime environment gdzie TypeScript wykonuje kod;Kontekst to deprecated mechanizm zastąpiony przez tsconfig w wersji 3.0;Kontekst to tylko lista plików .ts bez żadnej konfiguracji;0
Jak zadeklarować tablicę tylko z liczbami?;array<number> = [1,2,3] używając małej litery array;const arr: number[] = [1,2,3]; lub const arr: Array<number> = [1,2,3];. Błąd compile-time gdy dodam string;number arr[] = [1,2,3] jak w Java;Tablice w TypeScript nie mogą być typowane, zawsze są any[];1
Jak użyć Tuples dla różnych typów?;Tuples: const tuple: [string, number] = ['age', 25];. Można oznaczyć jako opcjonalne: [string, number?]. Bardziej specific niż union types;Tuples to przestarzała feature, używaj union types zamiast;tuple<string, number> = ['age', 25] z małej litery;Tuples nie istnieją w TypeScript, to feature z Python;0
Jak zdefiniować typ z określonymi wartościami?;Używaj enum: enum Size { Small, Medium, Large };;"Używaj type literals lub union: type Size = 'small' | 'medium' | 'large';. TypeScript sprawdza przy kompilacji";const Size = ['small', 'medium', 'large'] as const;Nie można ograniczyć wartości, TypeScript zawsze dopuszcza any string;1
Jak poprawić kod z błędem rzutowania?;Zawsze używaj any aby obejść błędy typów;Type assertions: const str = 'hello' as string;. Nowszy sposób: satisfies sprawdza typ ale zachowuje shape. satisfies preferowany;Rzutowanie nie istnieje w TypeScript;Używaj tylko <string> przed zmienną nigdy as;1
Kiedy użyć Union vs Intersection?;Union (|): wartość może być jednym z typów: type Status = 'success' | 'error'. Intersection (&): musi być wszystkim, kombinuje właściwości;Union i Intersection to synonimy w TypeScript;Używaj tylko Union, Intersection jest deprecated;Union dla typów prostych, Intersection dla obiektów zawsze;0
Jak użyć Mapped Types?;Mapped Types to deprecated feature z TypeScript 2.0;Mapped Types transformują typy: type Readonly<T> = { readonly [K in keyof T]: T[K]; }. Wbudowane: Partial, Readonly, Record, Pick;Mapped Types działają tylko w runtime nie compile-time;mapped<T> jako keyword przed definicją typu;1
Jak stworzyć typ warunkowy?;Conditional Types: type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;. infer captures typ. Zaawansowana feature;if-else w definicji typu: type MyType = if T then A else B;Typy warunkowe nie istnieją w TypeScript;Tylko dla primitive types nie dla obiektów;0
Czym różni się satisfies od zwykłej deklaracji?;satisfies sprawdza typ ale zachowuje original shape: const obj = {name: 'John'} satisfies {name: string;}. Zwykła deklaracja zmienia inferred type;satisfies to przestarzały keyword z TypeScript 3.0;Nie ma różnicy, satisfies to alias dla dwukropka;satisfies działa tylko dla interfejsów nie dla typów;0
Jak zdefiniować typ bez null i undefined?;NonNullable<T> filtruje null i undefined: type NonNullable<T> = T extends null | undefined ? never : T;. Lub Exclude;notNull<T> jako wbudowany utility type;Nie można wykluczyć null, TypeScript zawsze dopuszcza;? na końcu typu: string? oznacza non-nullable;0
Jak użyć Pick do wybrania pól?;Pick<T, K> wybiera określone właściwości: type UserPreview = Pick<User, 'id' | 'name'>;. Dopełnienie Pick to Omit;pick() jako funkcja runtime nie typ;Pick działa tylko dla interfejsów nie dla typów;Select<T, K> jest nową nazwą dla Pick od TypeScript 4.0;0
Jaka jest rola Omit w TypeScript?;Omit<T, K> usuwa określone właściwości: type UserWithoutEmail = Omit<User, 'email'>;. Przydatny dla DTO. Komplementarny do Pick;Omit to deprecated, używaj Exclude zamiast;omit() jako metoda na obiektach;Omit i Pick to synonimy;0
Jak użyć Record do mapowania kluczy?;Record<K, T> mapuje klucze typu K na wartości typu T: type Permissions = Record<Role, string[]>;. Lepsze od [key in Role]: string[];record() jako funkcja do tworzenia obiektów;Record to przestarzała nazwa dla Map<K,V>;Record działa tylko dla string keys;0
Jak napisać funkcję z Generics?;Generics to placeholders: function getFirst<T>(arr: T[]): T | undefined { return arr[0]; }. Mogę mieć wiele: function merge<A, B>;generic function getFirst(arr) używając keyword generic;Generics nie istnieją w TypeScript;Tylko klasy mogą mieć generics nie funkcje;0
Jak stworzyć Interface z opcjonalnymi właściwościami?;Używam ? na końcu: interface User { name: string; email?: string; }. ? oznacza opcjonalne. Lub Partial<User> dla wszystkich;optional keyword: interface User { optional email: string; };Wszystkie właściwości są domyślnie opcjonalne;! na końcu oznacza opcjonalne: email!: string;0
Jaki problem wynika ze zmiany private na public?;Nie ma problemu, to bezpieczna zmiana;Łamie enkapsulację - external code może modyfikować. Backward incompatible. Lepiej gettery/settery: private _name; get name();Zmiana private na public wymaga recompilacji całego projektu;Private i public to tylko sugestie, nie mają wpływu;1
Jak przeciążyć funkcję w TypeScript?;Overloading: function greet(name: string): void; function greet(name: string, age: number): void; function greet(name: string, age?: number) { };Przeciążanie nie istnieje w TypeScript;Używam @overload decorator nad każdą wersją;Wystarczy function greet(...args: any[]);0
Jak zaimportować ES Module w TypeScript?;import { myFunc } from './file'; lub import * as module from './file';. W tsconfig: module: 'esnext' lub 'commonjs';require('./file') jako jedyny sposób;import module from './file.ts' zawsze z rozszerzeniem .ts;ES Modules nie działają w TypeScript, tylko CommonJS;0
Jakie są kluczowe opcje w tsconfig.json?;strict: true (umbrella dla wszystkich checks), noImplicitAny (explicit typy), strictNullChecks, target (wersja JS), module (format). Zalecam strict: true;Tylko target i module są istotne, reszta jest optional;tsconfig.json jest deprecated, używaj package.json;compile: true jako najważniejsza opcja;0
Jak ustawić aliasy dla importów?;W tsconfig: baseUrl: '.', paths: { '@/*': ['src/*'] }. Zamiast '../../../../Button' mogę '@/components/Button'. Maintainable w dużych projektach;alias { '@': 'src' } w package.json;Aliasy nie są wspierane w TypeScript;import-alias plugin jest wymagany;0
Jaki jest wpływ wyłączenia noImplicitAny?;Nie ma wpływu, to deprecated opcja;Zmienne bez explicit type są any - tracimy type safety. Włączenie zmusza do explicit typów. Zawsze powinniśmy mieć noImplicitAny: true;noImplicitAny wyłączone sprawia że TypeScript działa szybciej;Wpływa tylko na funkcje nie na zmienne;1
