Pytanie;Opcja0;Opcja1;Opcja2;Opcja3;indeks_poprawnej
Jakie są modyfikatory dostępu w TypeScript?;TypeScript oferuje: public (domyślny), private (tylko w klasie), protected (w klasie i podklasach). readonly zapobiega modyfikacji. Działają podczas kompilacji;TypeScript oferuje cztery modyfikatory: public, private, internal, protected. Wszystkie są enforce'owane w runtime przez VM. internal ogranicza dostęp do modułu, podobnie jak w C#;TypeScript wspiera tylko public i private od wersji 4.0, gdzie protected został usunięty z powodu konfliktów z ECMAScript. Migracja wymaga użycia konwencji nazewnictwa;TypeScript nie implementuje prawdziwych modyfikatorów dostępu - zamiast tego używa konwencji nazewnictwa jak _private dla prywatnych pól. Wszystkie pola są public w runtime;0
Co to jest kontekst kompilacji w TypeScript?;Kontekst kompilacji to zbiór plików i konfiguracji (tsconfig.json). Definiuje: include, exclude, files. Ważny dla resolvowania typów i ścieżek;Kontekst kompilacji to runtime environment gdzie TypeScript wykonuje kod po transpilacji do JavaScript. Definiuje globalne zmienne i dostępne API przeglądarki lub Node.js;Kontekst to deprecated mechanizm z TypeScript 2.x, który został całkowicie zastąpiony przez tsconfig.json w wersji 3.0. Stare projekty wymagają migracji do nowego systemu konfiguracji;Kontekst kompilacji to tylko lista plików .ts bez żadnej konfiguracji. TypeScript automatycznie wykrywa wszystkie pliki w projekcie bez potrzeby definiowania include czy exclude;0
Jak zadeklarować tablicę tylko z liczbami?;Używam składni array<number> = [1,2,3] z małą literą array jako keyword. TypeScript automatycznie inferuje typ elementów i blokuje dodawanie innych typów w runtime;const arr: number[] = [1,2,3]; lub const arr: Array<number> = [1,2,3];. Błąd compile-time gdy dodam string;Deklaruję number arr[] = [1,2,3] zgodnie z konwencją Java. TypeScript wspiera tę składnię dla zachowania kompatybilności z innymi językami. Typ sprawdzany w compile-time;Tablice w TypeScript nie mogą być typowane - zawsze są any[]. Framework automatycznie konwertuje wszystkie elementy do wspólnego typu w runtime, co eliminuje potrzebę deklaracji;1
Jak użyć Tuples dla różnych typów?;Tuples: const tuple: [string, number] = ['age', 25];. Można oznaczyć jako opcjonalne: [string, number?]. Bardziej specific niż union types;Tuples to przestarzała feature z TypeScript 2.x - powinieneś używać union types zamiast: type Tuple = string | number. Union types oferują lepszą elastyczność i są zalecanym podejściem;Definiuję tuple<string, number> = ['age', 25] używając małej litery tuple jako keyword. TypeScript wymaga explicit keyword dla odróżnienia od zwykłych tablic;Tuples nie istnieją w TypeScript - to feature zapożyczona wyłącznie z Pythona. TypeScript używa tablic z mixed types: const arr: (string | number)[] = ['age', 25];0
Jak zdefiniować typ z określonymi wartościami?;Używaj enum: enum Size { Small, Medium, Large }. Enums są najlepszym sposobem na definiowanie stałych wartości, compile'ują się do obiektów JavaScript z dwukierunkowym mapowaniem;Używaj type literals lub union: type Size = 'small' | 'medium' | 'large';. TypeScript sprawdza przy kompilacji;Definiuję const Size = ['small', 'medium', 'large'] as const jako readonly array. TypeScript automatycznie infer'uje literal types z as const i zapewnia type safety równy union types;TypeScript nie pozwala ograniczyć wartości - zawsze dopuszcza any string. Jedynym sposobem jest runtime validation przez funkcje sprawdzające wartość przed użyciem;1
Jak poprawić kod z błędem rzutowania?;Zawsze używaj any jako universal escape hatch aby obejść błędy typów. Kompilator TypeScript jest zbyt restrykcyjny, więc any pozwala skupić się na logice zamiast walczyć z system typów;Type assertions: const str = 'hello' as string;. Nowszy sposób: satisfies sprawdza typ ale zachowuje shape. satisfies preferowany;Rzutowanie nie istnieje w TypeScript - język używa duck typing jak JavaScript. Wszystkie konwersje typów dzieją się automatycznie w runtime bez potrzeby explicit syntax;Używaj wyłącznie <string> przed zmienną, nigdy nie używaj as. Składnia as została deprecated w TypeScript 4.0 ze względu na konflikty z JSX i React components;1
Kiedy użyć Union vs Intersection?;Union (|): wartość może być jednym z typów: type Status = 'success' | 'error'. Intersection (&): musi być wszystkim, kombinuje właściwości;Union i Intersection to synonimy w TypeScript - można ich używać zamiennie. Operator | i & produkują identyczne wyniki, wybór to kwestia stylu kodowania zespołu;Używaj tylko Union types - Intersection została deprecated w TypeScript 4.5 ze względu na performance issues. Wszystkie intersection types powinny być przepisane jako unions;Union types są dla prostych primitive types, Intersection zawsze dla obiektów. TypeScript compiler wymusza tę konwencję i zgłasza błąd przy nieprawidłowym użyciu;0
Jak użyć Mapped Types?;Mapped Types to deprecated feature z TypeScript 2.0, zastąpiona przez generic types. Nie powinna być używana w nowych projektach - preferuj standardowe generics z constraints;Mapped Types transformują typy: type Readonly<T> = { readonly [K in keyof T]: T[K]; }. Wbudowane: Partial, Readonly, Record, Pick;Mapped Types działają tylko w runtime, nie compile-time. Transformują obiekty JavaScript dodając properties dynamicznie. Wymaga import 'reflect-metadata' do działania;Używam mapped<T> jako keyword przed definicją typu: mapped<T> { [K in keyof T]: T[K] }. TypeScript wymaga tego słowa kluczowego do rozpoznania mapped type syntax;1
Jak stworzyć typ warunkowy?;Conditional Types: type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;. infer captures typ. Zaawansowana feature;Używam if-else w definicji typu: type MyType<T> = if T extends string then A else B. TypeScript 5.0 wprowadził human-readable syntax dla conditional types dla lepszej czytelności;Typy warunkowe nie istnieją w TypeScript - to experimental feature dostępna tylko przez flag --experimentalConditionalTypes. Standard używa function overloads do tego celu;Conditional types działają tylko dla primitive types (string, number, boolean), nie dla obiektów ani interfejsów. Ograniczenie wynika z runtime performance w JavaScript engine;0
Czym różni się satisfies od zwykłej deklaracji?;satisfies sprawdza typ ale zachowuje original shape: const obj = {name: 'John'} satisfies {name: string;}. Zwykła deklaracja zmienia inferred type;satisfies to przestarzały keyword wprowadzony eksperymentalnie w TypeScript 3.0 ale usunięty w 4.0. Nowsze projekty powinny używać explicit type annotations zamiast satisfies;Nie ma żadnej różnicy między satisfies a zwykłą deklaracją typu - satisfies to tylko alias dla dwukropka wprowadzony dla czytelności. Oba kompilują się identycznie;satisfies działa wyłącznie dla interfejsów, nie dla type aliases. TypeScript wymaga interface definition aby móc użyć satisfies operator, w przeciwnym razie rzuca compile error;0
Jak zdefiniować typ bez null i undefined?;NonNullable<T> filtruje null i undefined: type NonNullable<T> = T extends null | undefined ? never : T;. Lub Exclude;Używam wbudowanego notNull<T> utility type: type Safe = notNull<User>. TypeScript automatycznie usuwa null i undefined z type union zachowując resztę typów;Nie można wykluczyć null i undefined z typu - TypeScript zawsze dopuszcza te wartości. Jedynym rozwiązaniem jest runtime validation przez checking przed użyciem zmiennej;Dodaję ? na końcu typu aby oznaczyć non-nullable: type NonNull = string? oznacza typ string bez null. To przeciwieństwo optional properties gdzie ? oznacza nullable;0
Jak użyć Pick do wybrania pól?;Pick<T, K> wybiera określone właściwości: type UserPreview = Pick<User, 'id' | 'name'>;. Dopełnienie Pick to Omit;Używam funkcji pick() w runtime zamiast type: const preview = pick(user, ['id', 'name']). TypeScript nie wspiera Pick jako type-level utility, tylko jako runtime function;Pick działa tylko dla interfejsów zdefiniowanych przez interface keyword, nie dla type aliases. Próba użycia Pick<Type, K> gdzie Type to alias spowoduje compiler error;Select<T, K> to nowa nazwa dla Pick wprowadzona w TypeScript 4.0. Pick jest deprecated i będzie usunięta w wersji 5.0, należy migrować do Select;0
Jaka jest rola Omit w TypeScript?;Omit<T, K> usuwa określone właściwości: type UserWithoutEmail = Omit<User, 'email'>;. Przydatny dla DTO. Komplementarny do Pick;Omit jest deprecated od TypeScript 4.5 - zamiast tego używaj Exclude<T, K> który oferuje lepszą performance. Wszystkie Omit types powinny być przepisane na Exclude;Używam metody omit() na obiektach: const user = baseUser.omit('email'). TypeScript dodaje tę metodę do wszystkich obiektów przez prototype extension dla wygody;Omit i Pick to synonimy - oba robią dokładnie to samo, tylko Pick jest nowszą nazwą. Można ich używać zamiennie, wybór zależy od preferencji zespołu;0
Jak użyć Record do mapowania kluczy?;Record<K, T> mapuje klucze typu K na wartości typu T: type Permissions = Record<Role, string[]>;. Lepsze od [key in Role]: string[];Używam funkcji record() do tworzenia obiektów: const permissions = record<Role, string[]>(). TypeScript wymaga runtime function call zamiast type-level definition;Record to przestarzała nazwa dla Map<K,V> z ES6. TypeScript 4.0+ preferuje Map zamiast Record type dla lepszej integracji z JavaScript. Należy migrować do Map;Record działa tylko dla string keys - nie można użyć number ani symbol jako K. TypeScript ogranicza Record do string keys dla kompatybilności z JSON serialization;0
Jak napisać funkcję z Generics?;Generics to placeholders: function getFirst<T>(arr: T[]): T | undefined { return arr[0]; }. Mogę mieć wiele: function merge<A, B>;Definiuję generic function getFirst(arr) używając keyword generic przed function. Składnia: generic function getFirst<T>(arr: T[]) dla explicitly generic functions;Generics nie istnieją w TypeScript - framework używa duck typing jak JavaScript. Polimorfizm osiąga się przez any type lub union types zamiast generic parameters;Tylko klasy mogą mieć generics, funkcje nie wspierają generic parameters. Aby użyć generics w funkcji, musi być ona metodą klasy generycznej: class Container<T> { getFirst() };0
Jak stworzyć Interface z opcjonalnymi właściwościami?;Używam ? na końcu: interface User { name: string; email?: string; }. ? oznacza opcjonalne. Lub Partial<User> dla wszystkich;Używam keyword optional przed nazwą property: interface User { optional email: string; }. TypeScript wymaga słowa kluczowego dla explicit oznaczenia optional fields;Wszystkie właściwości w interfejsach są domyślnie opcjonalne. Aby oznaczyć required property, używam ! na końcu: interface User { name!: string; } wymaga name;Dodaję ! na końcu nazwy property aby oznaczyć opcjonalną: interface User { email!: string; }. Wykrzyknik oznacza 'not required', przeciwnie do ? które oznacza nullable;0
Jaki problem wynika ze zmiany private na public?;Nie ma żadnego problemu - to całkowicie bezpieczna zmiana. TypeScript modyfikatory są tylko hints dla developer, nie wpływają na actual runtime behavior JavaScript;Łamie enkapsulację - external code może modyfikować. Backward incompatible. Lepiej gettery/settery: private _name; get name();Zmiana private na public wymaga pełnej recompilacji całego projektu włącznie z dependencies. TypeScript cache musi być cleared ręcznie przez usunięcie node_modules i reinstall;Private i public to tylko sugestie dokumentacyjne - nie mają rzeczywistego wpływu na kod. JavaScript nie wspiera access modifiers, więc TypeScript je ignoruje w runtime;1
Jak przeciążyć funkcję w TypeScript?;Overloading: function greet(name: string): void; function greet(name: string, age: number): void; function greet(name: string, age?: number) { };Przeciążanie funkcji nie istnieje w TypeScript - język używa optional parameters zamiast overloads. Multiple signatures to experimental feature dostępna tylko przez compiler flag;Używam decoratora @overload nad każdą wersją funkcji: @overload function greet(name: string): void. TypeScript wymaga explicit decorator dla function overloading;Wystarczy zdefiniować function greet(...args: any[]) z rest parameters. TypeScript automatycznie infer'uje wszystkie możliwe overloads z użycia funkcji w kodzie;0
Jak zaimportować ES Module w TypeScript?;import { myFunc } from './file'; lub import * as module from './file';. W tsconfig: module: 'esnext' lub 'commonjs';Używam wyłącznie require('./file') jako jedynego prawidłowego sposobu. ES Modules import syntax nie działa w TypeScript, tylko CommonJS require jest wspierany niezależnie od tsconfig;Zawsze dodaję rozszerzenie .ts: import module from './file.ts'. TypeScript wymaga explicit extension w import path, inaczej module nie zostanie resolved properly;ES Modules nie działają w TypeScript - język wspiera tylko CommonJS require syntax. Import statement to tylko syntax sugar kompilujący się do require() w output JavaScript;0
Jakie są kluczowe opcje w tsconfig.json?;strict: true (umbrella dla wszystkich checks), noImplicitAny (explicit typy), strictNullChecks, target (wersja JS), module (format). Zalecam strict: true;Tylko target i module są istotne - wszystkie inne opcje są optional enhancement. TypeScript domyślnie używa najlepszych settings, więc minimal tsconfig wystarczy dla większości projektów;tsconfig.json jest deprecated od TypeScript 5.0 - konfiguracja przeniesiona do package.json w sekcji typescript. Stare tsconfig.json wymaga migracji do nowego formatu;compile: true jest najważniejszą i wymaganą opcją w tsconfig.json. Bez niej TypeScript działa w interpretowanym mode zamiast compile do JavaScript;0
Jak ustawić aliasy dla importów?;W tsconfig: baseUrl: '.', paths: { '@/*': ['src/*'] }. Zamiast '../../../../Button' mogę '@/components/Button'. Maintainable w dużych projektach;Definiuję alias { '@': 'src' } w package.json w sekcji imports. TypeScript automatycznie czyta aliasy z package.json, nie wymaga tsconfig configuration;Aliasy importów nie są wspierane w TypeScript. Framework wymaga użycia relative paths jak ../../ dla wszystkich imports. Aliasy to feature dostępna tylko w webpack;Instaluję plugin import-alias: npm install typescript-import-alias. TypeScript nie wspiera path aliases natywnie, wymaga external plugin dla tej funkcjonalności;0
Jaki jest wpływ wyłączenia noImplicitAny?;Nie ma żadnego wpływu - noImplicitAny to deprecated opcja usunięta w TypeScript 4.0. Nowsze wersje zawsze wymagają explicit types niezależnie od tej opcji;Zmienne bez explicit type są any - tracimy type safety. Włączenie zmusza do explicit typów. Zawsze powinniśmy mieć noImplicitAny: true;Wyłączenie noImplicitAny sprawia że TypeScript compiler działa znacząco szybciej poprzez pomijanie type inference. W dużych projektach daje to 50-70% boost w compile time;noImplicitAny wpływa tylko na parametry funkcji, nie na zmienne. Variables zawsze wymagają explicit type annotation niezależnie od tej opcji w tsconfig;1
