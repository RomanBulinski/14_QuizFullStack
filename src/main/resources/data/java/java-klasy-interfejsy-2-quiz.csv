Pytanie;Opcja0;Opcja1;Opcja2;Opcja3;indeks_poprawnej
Czym jest moduł?;Moduł to alternatywna nazwa dla pakietu wprowadzona w Java 8;Moduł (Java 9+) to kontener klas w pakiety. Definiuje publiczny interfejs (exports) i zależności (requires). Buduje aplikacje z jasną separacją;Moduł to grupa interfejsów które muszą być implementowane razem;Moduł to plik JAR z manifestem zawierającym metadane o zależnościach;1
Czy moduły są alternatywą dla build tools?;Tak, moduły całkowicie zastępują Maven i Gradle od Java 9;Nie. Moduły (JPMS) to część JDK. Build tools (Maven, Gradle) są nadal potrzebne do zarządzania zależnościami zewnętrznymi;Moduły zastępują tylko Maven, Gradle nadal jest wymagany;Build tools są przestarzałe, moduły je całkowicie zastąpiły w Java 11;1
Jak utworzyć obiekt immutable w Javie?;Używając adnotacji @Immutable na klasie która automatycznie blokuje settery;Klasa final, pola private final, brak setters, zwracaj kopie mutable obiektów w getters, brak no-arg konstruktora;Wystarczy oznaczyć wszystkie pola jako final, reszta jest automatyczna;Implementować interfejs Immutable z pakietu java.lang.immutable;1
Jaka jest zaleta obiektów immutable?;Zajmują mniej pamięci dzięki kompresji JVM dla niezmiennych obiektów;Są szybsze w wykonaniu bo JVM używa specjalnej optymalizacji;Thread-safe bez synchronizacji, mogą być cache'owane, mogą być kluczami w mapach, łatwe do rozumienia, mniej bugów;Mogą być serializowane bez implementacji Serializable;2
Czym jest record?;Record to przestarzała nazwa dla enum wprowadzona w Java 5;Record to interfejs funkcyjny dla lambda expressions;Record (Java 14+) to szybki sposób na immutable klasę. Automatycznie tworzy konstruktor, getters, equals(), hashCode(), toString();Record to annotation processor generujący kod na podstawie adnotacji;2
Jakie cechy posiadają rekordy i gdzie mogą mieć zastosowanie?;Rekordy są mutable i mogą dziedziczyć klasy abstrakcyjne;Rekordy są immutable, auto-generują metody, mogą dziedzic interfejsy. Zastosowanie: DTO, wartościowe klasy, reprezentacja danych;Rekordy mogą być tylko lokalne wewnątrz metod, nie jako top-level classes;Rekordy zastępują wszystkie klasy POJO i są wymagane w Spring Boot od wersji 3;1
Czym jest konstruktor kanoniczny rekordu?;Konstruktor kanoniczny to konstruktor bez parametrów generowany automatycznie;Konstruktor kanoniczny to główny konstruktor rekordu ze wszystkimi komponentami. Może być jawnie zdefiniowany i customizowany;Konstruktor kanoniczny to konstruktor kopiujący dla tworzenia kopii rekordów;Konstruktor kanoniczny to przestarzała nazwa dla compact constructor;1
Jakie rodzaje konstruktorów oferują rekordy?;Tylko konstruktor kanoniczny, żadne inne konstruktory nie są dozwolone;Konstruktor kanoniczny (ze wszystkimi polami), konstruktory zwyczajne, compact constructors (do Java 16);Rekordy nie mogą mieć własnych konstruktorów, wszystko jest automatyczne;Constructor-on-demand pattern oraz lazy constructors dla optymalizacji;1
Czym jest przeciążanie metod?;Przeciążanie to zmiana implementacji metody w podklasie (override);Przeciążanie (overloading) to wiele metod o tej samej nazwie ale różnych parametrach. Parametry różnią się liczbą, typem lub kolejnością;Przeciążanie to używanie metod statycznych zamiast instancyjnych;Przeciążanie to mechanizm JVM do wyboru najszybszej implementacji metody;1
Jaka jest różnica między overriding a overloading?;Oba terminy oznaczają to samo, różnica jest tylko terminologiczna;Overloading to runtime polymorphism, overriding to compile-time polymorphism;Overriding: podklasa zmienia implementację metody z nadrzędnej (ta sama sygnatura). Overloading: wiele metod z tą samą nazwą ale różnymi parametrami;Overriding działa tylko dla metod statycznych, overloading dla instancyjnych;2
Do czego służy adnotacja @Override?;@Override oznacza że metoda nie może być nadpisana przez podklasy;@Override mówi kompilatorowi że metoda nadpisuje metodę z nadrzędnej. Kompilator zgłosi błąd jeśli nie nadpisuje nic;@Override zwiększa wydajność metody przez optymalizację JVM;@Override jest przestarzała i zastąpiona przez @Overridden w Java 11;1
Czym są typy wyliczeniowe?;Enum to interfejs funkcyjny używany w lambda expressions;Enum to typ którego wartości są predefiniowane. Mogą zawierać pola i metody. Przykład: enum Color { RED, GREEN, BLUE; };Enum to przestarzała struktura zastąpiona przez sealed classes w Java 15;Enum to klasa abstrakcyjna z metodami statycznymi dla każdej wartości;1
Jak zaimplementować składowe typów wyliczeniowych?;Przykład: enum Color { RED(255); int value; Color(int v) { value = v; } public int getValue() { return value; } };Enums nie mogą mieć pól ani metod, tylko wartości;Używając adnotacji @EnumField i @EnumMethod na odpowiednich składowych;Pola i metody w enums są możliwe tylko jeśli enum implementuje interfejs;0
Czym jest klasa anonimowa?;Klasa anonimowa to klasa bez modyfikatora dostępu (package-private);Klasa anonimowa to klasa której nazwa jest generowana losowo przez JVM;Klasa anonimowa to klasa bez nazwy zdefiniowana in-line. Dziedziczy klasę lub implementuje interfejs. Używana do zdarzeń i callbacks;Klasa anonimowa to klasa zdefiniowana w oddzielnym pliku bez deklaracji package;2
Czym jest klasa lokalna?;Klasa lokalna to klasa zdefiniowana w lokalnym pakiecie projektu;Klasa lokalna to klasa dostępna tylko w danym module od Java 9;Klasa lokalna to klasa zdefiniowana wewnątrz metody. Dostęp tylko wewnątrz metody;Klasa lokalna to klasa z modyfikatorem local wprowadzonym w Java 10;2
Czym są klasy wewnętrzne?;Klasy wewnętrzne to klasy zdefiniowane w wewnętrznych pakietach (internal packages);Klasy wewnętrzne to wszystkie klasy które nie są public;Klasy wewnętrzne (inner classes) to klasy zdefiniowane w innej klasie. Mają dostęp do pól klasy zewnętrznej. Mogą być non-static;Klasy wewnętrzne to klasy implementujące interfejs InnerClass z java.lang;2
Czym są klasy zagnieżdżone?;Klasy zagnieżdżone to klasy w głębokich strukturach dziedziczenia;Klasy zagnieżdżone to klasy wewnątrz innej klasy. Jeśli statyczne to zagnieżdżone, jeśli nie to wewnętrzne;Klasy zagnieżdżone to pattern projektowy dla kompozycji obiektów;Klasy zagnieżdżone to klasy w zagnieżdżonych pakietach (np. com.example.nested.Class);1
Jaka jest różnica między klasą wewnętrzną a zagnieżdżoną?;Nie ma różnicy, to synonimy wprowadzone dla kompatybilności z C++;Klasa zagnieżdżona może być public, klasa wewnętrzna musi być private;Klasa wewnętrzna (non-static) ma dostęp do pól instancji zewnętrznej. Klasa zagnieżdżona (static) ma dostęp tylko do statycznych;Klasa wewnętrzna jest w metodzie, klasa zagnieżdżona w klasie;2
Jakie są ryzyka zwrócenia obiektów klas wewnętrznych poza zakres?;Brak ryzyka, JVM automatycznie zarządza referencjami;Klasa wewnętrzna utrzymuje ukrytą referencję do zewnętrznej co może zapobiec garbage collection zewnętrznej, powodując wyciek pamięci;Zwrócenie obiektu klasy wewnętrznej powoduje CloneNotSupportedException;Obiekt klasy wewnętrznej automatycznie staje się null gdy wyjdzie poza zakres;1
Czy klasy wewnętrzne mają dostęp do składowych klasy zewnętrznej?;Nie, klasy wewnętrzne są kompletnie izolowane jak klasy statyczne;Tak, klasy wewnętrzne (non-static) mają dostęp do pól private klasy zewnętrznej;Tylko do pól publicznych zgodnie z zasadami enkapsulacji;Dostęp jest możliwy tylko przez specjalny interfejs OuterAccess;1
Czy klasy wewnętrzne można dziedziczyć?;Nie, klasy wewnętrzne są final i nie mogą być dziedziczone;Tak, można dziedziczyć klasy wewnętrzne ale wymaga specjalnej składni z konstruktorem klasy zewnętrznej;Tylko jeśli klasa zewnętrzna implementuje interfejs Inheritable;Dziedziczenie klas wewnętrznych jest możliwe tylko od Java 11;1
Czy argumenty w Javie są przekazywane przez wartość czy referencję?;Java przekazuje typy proste przez wartość, obiekty przez referencję;Java przekazuje argumenty przez wartość. Dla prostych: kopia wartości. Dla obiektów: kopia referencji (nie sama referencja);Java przekazuje wszystko przez referencję dla optymalizacji pamięci;Od Java 8 używa się pass-by-sharing jako nowy mechanizm;1
Czym jest referencja w Javie?;Referencja to słowo kluczowe ref używane do oznaczania parametrów;Referencja to wskaźnik z możliwością arytmetyki wskaźników jak w C++;Referencja to adres do obiektu w pamięci (heap). Zmienna przechowuje referencję nie sam obiekt;Referencja to interfejs Reference z pakietu java.lang.ref;2
Dlaczego Java ma NullPointerException skoro nie ma wskaźników?;To błąd nazewnictwa, powinno być NullReferenceException;W Javie referencje (wskaźniki) istnieją ale są ukryte. NullPointerException gdy próbujesz dostać się do obiektu przez null referencję;Java ma wskaźniki ale są one ukryte przez słowo kluczowe pointer;NPE to legacy z Java 1.0, teraz nazywa się NullException;1
Czym jest rzutowanie typów?;Rzutowanie to mechanizm JVM do optymalizacji typów w runtime;Rzutowanie to konwersja obiektu z jednego typu na inny. Jawne: (Type) object. Niejawne: automatycznie przez kompilator;Rzutowanie to kopiowanie obiektu do nowego typu przez clone();Rzutowanie to przestarzały mechanizm zastąpiony przez var w Java 10;1
Co to instanceof i jak działa?;instanceof to operator tworzenia nowej instancji klasy;instanceof sprawdza czy obiekt jest instancją danej klasy lub interfejsu. Zwraca boolean. Od Java 16 pattern matching;instanceof to metoda z Object do sprawdzania równości typów;instanceof działa tylko dla interfejsów nie dla klas;1
Czym jest statyczny blok inicjalizacji?;Statyczny blok to metoda main() która jest wywoływana przy starcie;Statyczny blok to blok wykonywany raz gdy klasa jest ładowana do pamięci. static { } Używany do inicjalizacji zmiennych statycznych;Statyczny blok to konstruktor dla klas abstrakcyjnych;Statyczny blok to deprecated mechanizm zastąpiony przez @PostConstruct;1
Jaka jest kolejność statycznej inicjalizacji?;Konstruktor, potem zmienne statyczne, na końcu bloki statyczne;Wszystko jest inicjalizowane równolegle w różnych wątkach;Zmienne statyczne (wartość domyślna), statyczne bloki inicjalizacji (w kolejności), konstruktor dla instancji;Kolejność jest losowa i zależy od JVM implementation;2
