Pytanie;Opcja0;Opcja1;Opcja2;Opcja3;indeks_poprawnej
Czym jest moduł?;Moduł to alternatywna nazwa dla pakietu Java która została wprowadzona w Java 8 dla lepszej semantyki i zgodności z innymi językami JVM;Moduł (Java 9+) to kontener klas w pakiety. Definiuje publiczny interfejs (exports) i zależności (requires). Buduje aplikacje z jasną separacją;Moduł to grupa ściśle powiązanych interfejsów funkcyjnych które muszą być obowiązkowo implementowane razem jako spójny komponent;Moduł to specjalnie sformatowany plik archiwum JAR z manifestem META-INF zawierającym szczegółowe metadane o wszystkich zależnościach;1
Czy moduły są alternatywą dla build tools?;Tak, moduły Java całkowicie zastępują funkcjonalność Maven i Gradle od wersji Java 9 i nowszych;Nie. Moduły (JPMS) to część JDK. Build tools (Maven, Gradle) są nadal potrzebne do zarządzania zależnościami zewnętrznymi;Moduły Java zastępują tylko Maven w ekosystemie build tools, jednak Gradle nadal jest wymagany dla zarządzania zależnościami;Build tools Maven i Gradle są oficjalnie przestarzałe od Java 11, moduły JPMS je całkowicie zastąpiły zgodnie z Oracle roadmap;1
Jak utworzyć obiekt immutable w Javie?;Używając specjalnej adnotacji @Immutable na definicji klasy która automatycznie blokuje wszystkie metody settery i modyfikacje stanu;Klasa final, pola private final, brak setters, zwracaj kopie mutable obiektów w getters, brak no-arg konstruktora;Wystarczy oznaczyć wszystkie pola jako final używając modyfikatora final, reszta niezmienności jest automatycznie zapewniana przez JVM;Klasa musi implementować specjalny marker interface Immutable dostępny w pakiecie java.lang.immutable od Java 8;1
Jaka jest zaleta obiektów immutable?;Obiekty niezmienne zajmują znacząco mniej pamięci operacyjnej dzięki specjalnej kompresji heap memory wykonanej przez JVM dla immutable objects;Obiekty immutable są znacznie szybsze w wykonaniu gdyż JVM używa dedykowanych optymalizacji Just-In-Time compiler dla niezmiennych struktur;Thread-safe bez synchronizacji, mogą być cache'owane, mogą być kluczami w mapach, łatwe do rozumienia, mniej bugów;Obiekty immutable mogą być automatycznie serializowane i deserializowane bez potrzeby implementacji interfejsu Serializable;2
Czym jest record?;Record to przestarzała nazwa dla typów wyliczeniowych enum która była używana w wersji Java 5 przed zmianą terminologii;Record to specjalny interfejs funkcyjny wprowadzony w Java 8 do użycia z lambda expressions i method references;Record (Java 14+) to szybki sposób na immutable klasę. Automatycznie tworzy konstruktor, getters, equals(), hashCode(), toString();Record to zaawansowany annotation processor generujący automatycznie kod Java na podstawie zdefiniowanych adnotacji;2
Jakie cechy posiadają rekordy i gdzie mogą mieć zastosowanie?;Rekordy są domyślnie mutable i mogą swobodnie dziedziczyć zarówno klasy abstrakcyjne jak i inne konkretne klasy;Rekordy są immutable, auto-generują metody, mogą dziedzic interfejsy. Zastosowanie: DTO, wartościowe klasy, reprezentacja danych;Rekordy mogą być definiowane wyłącznie jako lokalne wewnątrz metod, nie mogą występować jako top-level classes w plikach;Rekordy całkowicie zastępują wszystkie tradycyjne klasy POJO i są obowiązkowe wymagane w Spring Boot od wersji 3.0;1
Czym jest konstruktor kanoniczny rekordu?;Konstruktor kanoniczny to specjalny konstruktor bez parametrów który jest automatycznie generowany dla każdego rekordu przez kompilator;Konstruktor kanoniczny to główny konstruktor rekordu ze wszystkimi komponentami. Może być jawnie zdefiniowany i customizowany;Konstruktor kanoniczny to specjalny konstruktor kopiujący który służy do tworzenia głębokich kopii istniejących obiektów rekordów;Konstruktor kanoniczny to oficjalnie przestarzała nazwa dla compact constructor która została zmieniona w Java 16;1
Jakie rodzaje konstruktorów oferują rekordy?;Rekordy mogą posiadać tylko konstruktor kanoniczny, żadne inne dodatkowe konstruktory nie są dozwolone zgodnie z JLS;Konstruktor kanoniczny (ze wszystkimi polami), konstruktory zwyczajne, compact constructors (do Java 16);Rekordy w ogóle nie mogą mieć własnych konstruktorów zdefiniowanych przez programistę, wszystko jest całkowicie automatyczne;Rekordy oferują zaawansowany constructor-on-demand pattern oraz lazy constructors dla optymalizacji pamięci i wydajności;1
Czym jest przeciążanie metod?;Przeciążanie to proces zmiany i modyfikacji implementacji metody w klasie podrzędnej znanej również jako override;Przeciążanie (overloading) to wiele metod o tej samej nazwie ale różnych parametrach. Parametry różnią się liczbą, typem lub kolejnością;Przeciążanie to specjalna technika używania metod statycznych zamiast metod instancyjnych dla optymalizacji wydajności aplikacji;Przeciążanie to zaawansowany mechanizm JVM do dynamicznego wyboru najszybszej implementacji metody w czasie działania programu;1
Jaka jest różnica między overriding a overloading?;Oba terminy oznaczają dokładnie to samo, różnica między nimi jest wyłącznie terminologiczna i zależy od preferencji programisty;Overloading to mechanizm runtime polymorphism działający dynamicznie, overriding to mechanizm compile-time polymorphism działający statycznie;Overriding: podklasa zmienia implementację metody z nadrzędnej (ta sama sygnatura). Overloading: wiele metod z tą samą nazwą ale różnymi parametrami;Overriding działa wyłącznie dla metod statycznych, natomiast overloading może być używany tylko dla metod instancyjnych;2
Do czego służy adnotacja @Override?;Adnotacja @Override oznacza że dana metoda nie może być w przyszłości nadpisana przez żadne klasy podrzędne;@Override mówi kompilatorowi że metoda nadpisuje metodę z nadrzędnej. Kompilator zgłosi błąd jeśli nie nadpisuje nic;Adnotacja @Override znacząco zwiększa wydajność wykonania metody poprzez specjalne optymalizacje Just-In-Time compiler w JVM;Adnotacja @Override jest oficjalnie przestarzała deprecated i została całkowicie zastąpiona przez @Overridden w Java 11;1
Czym są typy wyliczeniowe?;Enum to specjalny interfejs funkcyjny wprowadzony w Java 8 który jest używany wyłącznie w kontekście lambda expressions;Enum to typ którego wartości są predefiniowane. Mogą zawierać pola i metody. Przykład: enum Color { RED, GREEN, BLUE; };Enum to przestarzała struktura danych z Java 5 która została całkowicie zastąpiona przez sealed classes wprowadzone w Java 15;Enum to specjalna klasa abstrakcyjna z automatycznie wygenerowanymi metodami statycznymi factory dla każdej predefiniowanej wartości;1
Jak zaimplementować składowe typów wyliczeniowych?;Przykład: enum Color { RED(255); int value; Color(int v) { value = v; } public int getValue() { return value; } };Typy wyliczeniowe enum w Java nie mogą w ogóle posiadać żadnych własnych pól ani metod, tylko wartości;Należy używać specjalnych adnotacji @EnumField i @EnumMethod na odpowiednich składowych dla oznaczenia ich jako część enuma;Pola i metody w typach enum są technicznie możliwe tylko jeśli enum implementuje przynajmniej jeden interfejs;0
Czym jest klasa anonimowa?;Klasa anonimowa to klasa która nie posiada żadnego modyfikatora dostępu i jest domyślnie package-private w hierarchii pakietów;Klasa anonimowa to klasa której unikalna nazwa jest automatycznie generowana losowo przez JVM podczas ładowania klasy;Klasa anonimowa to klasa bez nazwy zdefiniowana in-line. Dziedziczy klasę lub implementuje interfejs. Używana do zdarzeń i callbacks;Klasa anonimowa to klasa zdefiniowana w całkowicie oddzielnym pliku źródłowym bez żadnej deklaracji package na początku;2
Czym jest klasa lokalna?;Klasa lokalna to klasa zdefiniowana w lokalnym pakiecie projektu zgodnie z hierarchią modułów i package structure;Klasa lokalna to klasa która jest dostępna wyłącznie w obrębie danego modułu od wprowadzenia JPMS w Java 9;Klasa lokalna to klasa zdefiniowana wewnątrz metody. Dostęp tylko wewnątrz metody;Klasa lokalna to klasa oznaczona specjalnym modyfikatorem local który został wprowadzony jako feature w Java 10;2
Czym są klasy wewnętrzne?;Klasy wewnętrzne to wszystkie klasy zdefiniowane w specjalnych wewnętrznych pakietach internal packages zgodnie z konwencją nazewnictwa;Klasy wewnętrzne to dokładnie wszystkie klasy w projekcie które nie posiadają modyfikatora dostępu public;Klasy wewnętrzne (inner classes) to klasy zdefiniowane w innej klasie. Mają dostęp do pól klasy zewnętrznej. Mogą być non-static;Klasy wewnętrzne to klasy które implementują specjalny marker interface InnerClass dostępny w pakiecie java.lang;2
Czym są klasy zagnieżdżone?;Klasy zagnieżdżone to klasy znajdujące się głęboko w strukturach dziedziczenia z wieloma poziomami hierarchii klas;Klasy zagnieżdżone to klasy wewnątrz innej klasy. Jeśli statyczne to zagnieżdżone, jeśli nie to wewnętrzne;Klasy zagnieżdżone to zaawansowany pattern projektowy służący do implementacji kompozycji obiektów w architekturze aplikacji;Klasy zagnieżdżone to klasy zdefiniowane w zagnieżdżonych pakietach używając hierarchii typu com.example.nested.deep.Class;1
Jaka jest różnica między klasą wewnętrzną a zagnieżdżoną?;Nie istnieje żadna różnica, oba terminy są synonimami wprowadzonymi historycznie dla zachowania kompatybilności z językiem C++;Klasa zagnieżdżona może posiadać modyfikator public, natomiast klasa wewnętrzna bezwzględnie musi być oznaczona jako private;Klasa wewnętrzna (non-static) ma dostęp do pól instancji zewnętrznej. Klasa zagnieżdżona (static) ma dostęp tylko do statycznych;Klasa wewnętrzna jest zawsze definiowana wewnątrz metody, klasa zagnieżdżona jest definiowana bezpośrednio w ciele klasy;2
Jakie są ryzyka zwrócenia obiektów klas wewnętrznych poza zakres?;Nie ma żadnego ryzyka, Java Virtual Machine automatycznie zarządza wszystkimi referencjami i cyklem życia obiektów;Klasa wewnętrzna utrzymuje ukrytą referencję do zewnętrznej co może zapobiec garbage collection zewnętrznej, powodując wyciek pamięci;Zwrócenie obiektu klasy wewnętrznej poza jej naturalny zakres automatycznie powoduje wyrzucenie CloneNotSupportedException;Obiekt klasy wewnętrznej jest automatycznie ustawiany na null przez garbage collector gdy tylko wyjdzie poza swój zakres;1
Czy klasy wewnętrzne mają dostęp do składowych klasy zewnętrznej?;Nie, klasy wewnętrzne są kompletnie izolowane i zachowują się dokładnie tak samo jak klasy statyczne;Tak, klasy wewnętrzne (non-static) mają dostęp do pól private klasy zewnętrznej;Klasy wewnętrzne mają dostęp tylko do pól publicznych klasy zewnętrznej zgodnie z fundamentalnymi zasadami enkapsulacji;Dostęp do składowych zewnętrznych jest możliwy tylko poprzez specjalny dedykowany interfejs OuterAccess;1
Czy klasy wewnętrzne można dziedziczyć?;Nie, wszystkie klasy wewnętrzne są automatycznie final i w żaden sposób nie mogą być dziedziczone przez inne klasy;Tak, można dziedziczyć klasy wewnętrzne ale wymaga specjalnej składni z konstruktorem klasy zewnętrznej;Dziedziczenie klas wewnętrznych jest możliwe tylko wtedy gdy klasa zewnętrzna implementuje specjalny marker interface Inheritable;Dziedziczenie klas wewnętrznych stało się technicznie możliwe dopiero od wprowadzenia ulepszeń w Java 11;1
Czy argumenty w Javie są przekazywane przez wartość czy referencję?;Java używa mieszanego podejścia przekazując typy proste przez wartość a wszystkie obiekty przez bezpośrednią referencję;Java przekazuje argumenty przez wartość. Dla prostych: kopia wartości. Dla obiektów: kopia referencji (nie sama referencja);Java przekazuje absolutnie wszystko przez referencję dla maksymalnej optymalizacji wykorzystania pamięci i wydajności;Od wprowadzenia Java 8 używa się nowego mechanizmu pass-by-sharing jako alternatywy dla tradycyjnego przekazywania;1
Czym jest referencja w Javie?;Referencja to specjalne słowo kluczowe ref które jest używane do oznaczania parametrów przekazywanych przez referencję;Referencja to technicznie wskaźnik z pełną możliwością arytmetyki wskaźników podobnie jak w języku C++;Referencja to adres do obiektu w pamięci (heap). Zmienna przechowuje referencję nie sam obiekt;Referencja to specjalny interfejs Reference dostępny w standardowym pakiecie java.lang.ref dla weak references;2
Dlaczego Java ma NullPointerException skoro nie ma wskaźników?;Jest to historyczny błąd nazewnictwa z Java 1.0, poprawna nazwa powinna brzmieć NullReferenceException;W Javie referencje (wskaźniki) istnieją ale są ukryte. NullPointerException gdy próbujesz dostać się do obiektu przez null referencję;Java faktycznie posiada wskaźniki ale są one całkowicie ukryte za specjalnym słowem kluczowym pointer;NPE to legacy exception z Java 1.0 które zostało przemianowane na NullException w nowszych wersjach;1
Czym jest rzutowanie typów?;Rzutowanie to zaawansowany mechanizm JVM służący do automatycznej optymalizacji typów obiektów w czasie działania runtime;Rzutowanie to konwersja obiektu z jednego typu na inny. Jawne: (Type) object. Niejawne: automatycznie przez kompilator;Rzutowanie to proces głębokiego kopiowania obiektu do zupełnie nowego typu poprzez wywołanie metody clone();Rzutowanie to przestarzały mechanizm z wczesnych wersji Java całkowicie zastąpiony przez var inference w Java 10;1
Co to instanceof i jak działa?;instanceof to specjalny operator służący do tworzenia nowej instancji danej klasy podobnie jak operator new;instanceof sprawdza czy obiekt jest instancją danej klasy lub interfejsu. Zwraca boolean. Od Java 16 pattern matching;instanceof to statyczna metoda dziedziczona z klasy Object służąca do sprawdzania równości typów obiektów;instanceof to operator który działa wyłącznie dla interfejsów ale nie może być używany dla zwykłych klas;1
Czym jest statyczny blok inicjalizacji?;Statyczny blok inicjalizacji to alternatywna nazwa dla metody main() która jest automatycznie wywoływana przy starcie aplikacji;Statyczny blok to blok wykonywany raz gdy klasa jest ładowana do pamięci. static { } Używany do inicjalizacji zmiennych statycznych;Statyczny blok to specjalny konstruktor który jest używany wyłącznie dla klas abstrakcyjnych w hierarchii dziedziczenia;Statyczny blok to oficjalnie deprecated mechanizm z Java 5 który został całkowicie zastąpiony przez adnotację @PostConstruct;1
Jaka jest kolejność statycznej inicjalizacji?;Najpierw wykonywany jest konstruktor obiektu, potem inicjalizowane są zmienne statyczne, na samym końcu wykonywane są bloki statyczne;Wszystkie składowe statyczne są inicjalizowane równolegle w różnych wątkach dla maksymalnej optymalizacji wydajności;Zmienne statyczne (wartość domyślna), statyczne bloki inicjalizacji (w kolejności), konstruktor dla instancji;Kolejność inicjalizacji statycznej jest całkowicie losowa i zależy wyłącznie od konkretnej implementacji JVM;2
