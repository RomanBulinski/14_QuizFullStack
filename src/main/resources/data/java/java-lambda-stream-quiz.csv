Pytanie;Opcja0;Opcja1;Opcja2;Opcja3;indeks_poprawnej
Czym jest interfejs funkcyjny?;Interfejs z dokładnie jedną abstrakcyjną metodą (SAM). Może mieć domyślne metody i statyczne;Interfejs który implementuje Function<T,R> jako swoją bazową klasę oraz dziedziczy wszystkie metody z pakietu java.util.function;Interfejs bez żadnych metod używany jako marker dla kompilatora do oznaczania klas które mogą być używane w wyrażeniach lambda;Interfejs z adnotacją @FunctionalInterface który może mieć dowolną liczbę abstrakcyjnych metod ale wymaga przynajmniej trzech default methods;0
Czy interfejs funkcyjny może mieć wiele metod?;Tak, interfejs funkcyjny może mieć dowolną liczbę abstrakcyjnych metod oraz nie ma żadnych ograniczeń jeśli chodzi o liczbę deklarowanych metod;Nie, funkcyjny interfejs może mieć tylko jedną abstrakcyjną metodę. Ale może mieć domyślne i statyczne;Może mieć maksymalnie 3 abstrakcyjne metody zgodnie z ograniczeniami nałożonymi przez specyfikację JLS w rozdziale o interfaces funkcyjnych;Od Java 11 interfejs funkcyjny może mieć wiele abstrakcyjnych metod jeśli są one oznaczone adnotacją @LambdaCompatible dla każdej z nich;1
Czym są interfejsy Predicate oraz BiPredicate?;Predicate<T>: T -> boolean. BiPredicate<T, U>: (T, U) -> boolean. Używane do testowania warunków w streamach;Predicate to przestarzała nazwa dla Function<T,Boolean> która została zastąpiona w Java 9. BiPredicate w ogóle nie istnieje w standardowej bibliotece;Predicate: T -> T. BiPredicate: (T, U) -> (T, U) są używane do transformacji obiektów podczas przetwarzania sekwencji elementów w Stream API;Predicate to klasa abstrakcyjna nie interfejs która wymaga implementacji metody abstract boolean evaluate(T value) w każdej podklasie;0
Czym są interfejsy Consumer oraz BiConsumer?;Consumer<T>: T -> void. BiConsumer<T, U>: (T, U) -> void. Używane do wykonania operacji na elementach;Consumer: T -> T do konsumpcji wartości poprzez modyfikację przekazanego obiektu i zwrócenie go. BiConsumer działa podobnie ale dla dwóch parametrów;Consumer to deprecated interfejs z Java 7 który został zastąpiony przez Function<T,Void> w nowszych wersjach języka Java;Consumer i BiConsumer to klasy nie interfejsy które są instancjonowane jako new Consumer<String>() z przekazaniem implementacji w konstruktorze;0
Czym jest wyrażenie lambda?;Lambda to klasa anonimowa zapisana w krótszej formie ale kompilowana do identycznego bytecode z pełną definicją klasy wewnętrznej;Lambda (Java 8+) to anonimowa funkcja. Syntax: (params) -> body. Przykład: (x, y) -> x + y;Lambda to metoda statyczna którą można przekazywać jako referencję i która jest automatycznie inlinowana przez JVM dla optymalizacji wydajności;Lambda to przestarzała feature która została zastąpiona przez method references w Java 11 ze względu na lepszą czytelność kodu;1
Jakie znasz interfejsy z pakietu java.util.function?;Function<T,R>, Predicate<T>, Consumer<T>, Supplier<T>, BiFunction<T,U,R>. Stanowią standardowe interfejsy funkcyjne dla lambdów;Lambda, Stream, Optional, Collector jako główne interfejsy które definiują podstawową funkcjonalność dla functional programming w Java;Map, Filter, Reduce, Collect jako interfejsy funkcyjne reprezentujące operacje na kolekcjach wprowadzone w Java Collections Framework 2.0;Tylko Function<T,R> jest prawdziwym interfejsem funkcyjnym, reszta to klasy pomocnicze znajdujące się w pakiecie java.util.stream dla wsparcia Stream API;0
Czym jest method reference?;Method reference to deprecated składnia dla lambdów która została usunięta w Java 11 ze względu na problemy z type inference w kompilatorze;Method reference to skrót do wyrażenia lambda które wywoła istniejącą metodę. Syntax: Class::method. Przykład: String::toUpperCase;Method reference to sposób na tworzenie metod generycznych które mogą przyjmować dowolne typy parametrów poprzez użycie wildcard <? extends Object>;Method reference działa tylko dla metod statycznych i nie może być używany z metodami instancyjnymi ze względu na ograniczenia JVM bytecode;1
Czym są nieskończone stream-y i jak na nich operować?;Nieskończone streamy są niemożliwe w Java ponieważ JVM ma ograniczenia pamięci i każdy stream musi mieć określony rozmiar podczas konstrukcji;Stream.generate(() -> value) lub Stream.iterate(start, func). Muszą być ograniczane za pomocą limit() lub findFirst();Wszystkie streamy są domyślnie nieskończone dopóki nie wywołasz terminal operation która automatycznie ogranicza stream do rozsądnego rozmiaru;Nieskończone streamy wymagają adnotacji @Infinite na metodzie która je tworzy oraz specjalnej konfiguracji JVM przez parametr -XX:AllowInfiniteStreams;1
Czy lambda może wyrzucić wyjątek?;Tak, lambda może wyrzucać dowolne wyjątki checked i unchecked bez żadnych ograniczeń podobnie jak zwykłe metody w klasach;Jeśli wyjątek jest checked, nie bezpośrednio. Musisz go wrappować lub użyć custom functional interface z throws;Lambda nigdy nie może wyrzucać żadnych wyjątków ponieważ interfejsy funkcyjne z java.util.function nie deklarują throws w swoich metodach;Tylko RuntimeException może być wyrzucany z lambdów zgodnie z ograniczeniami nałożonymi przez specyfikację języka Java w JLS 15.27;1
Czym są collectory dla stream-ów?;Collectory to deprecated mechanizm z Java 8 który został zastąpiony przez toList(), toSet() jako default methods na interfejsie Stream;Collectory transformują elementy stream do Collections. Przykład: Collectors.toList(), groupingBy(), joining();Collectory to interfejsy funkcyjne używane do zbierania statystyk o danych przetwarzanych w stream takich jak średnia, suma oraz count;Collectory działają tylko dla parallel streams i są automatycznie pomijane gdy używasz sequential stream ze względu na optymalizację;1
Jak obsłużyć wyjątki checked w przypadku wyrażeń lambda?;Checked wyjątki są automatycznie konwertowane na unchecked przez kompilator Java 8+ podczas kompilacji wyrażeń lambda do bytecode;Wrappuj wyjątek w unchecked Exception lub utwórz custom functional interface. Przykład: e -> { try { } catch(...) {} };Nie można w ogóle obsługiwać checked wyjątków w lambda expressions zgodnie z ograniczeniami functional interfaces z pakietu java.util.function;Używaj adnotacji @CheckedLambda przed deklaracją wyrażenia lambda która informuje kompilator że może być wyrzucony checked exception;1
Jakie zalety mają stream-y?;Tylko wydajność jest zaletą streamów ponieważ są znacznie szybsze od tradycyjnych pętli przez wewnętrzną optymalizację JVM bytecode;Deklaratywne (co chcesz nie jak), lazy evaluation, łatwo paralelizować, readable, functional programming;Streamy są zawsze szybsze od pętli for i while bez wyjątków oraz zużywają mniej pamięci przez wewnętrzny cache mechanizm;Główna zaleta to automatyczne zamykanie zasobów przez try-with-resources który jest wbudowany w każdy stream jako część AutoCloseable;1
Czym jest Optional? Gdzie się go w praktyce używa?;Optional to kontener dla kolekcji elementów podobny do List ale z dodatkowymi metodami do obsługi braku wartości w sekwencji;Optional<T> to kontener który może zawierać wartość lub być pusty. Używany zamiast null. Metody: isPresent(), get(), orElse(), map();Optional to przestarzały mechanizm z Java 8 który został zastąpiony przez nullable types wprowadzone w Java 14 jako część pattern matching;Optional działa tylko ze streamami jako wynik operacji findFirst() i findAny() oraz nie może być używany jako zwykły typ w innych kontekstach;1
Czy stream-y są lazy?;Nie, wszystkie operacje intermediate i terminal wykonują się natychmiast w momencie wywołania bez żadnego opóźnienia czy optymalizacji;Tak, operacje intermediate (map, filter) nie są wykonywane aż do terminal operation (collect, forEach);Tylko parallel streams są lazy podczas gdy sequential streams wykonują operacje eager dla zachowania spójności semantyki single-threaded;Stream-y są lazy tylko w Java 11+ ze względu na wprowadzenie nowego mechanizmu lazy evaluation w JVM który nie istniał wcześniej;1
Czym jest stream?;Stream to kolekcja która przechowuje dane w pamięci podobnie jak ArrayList ale z dodatkowymi metodami funkcyjnymi do przetwarzania;Stream to sekwencja elementów z funkcyjnymi operacjami. Nie przechowuje danych, operuje na źródle;Stream to deprecated nazwa dla Iterator która była używana w wersji beta Java 8 przed finalnym wydaniem języka;Stream to interfejs dla I/O operacji który został przeniesiony z pakietu java.io do java.util.stream w Java 8 dla lepszej spójności;1
Czy stream-y są stateful czy stateless?;Wszystkie operacje na streamach są stateful ponieważ muszą przechowywać informacje o poprzednich elementach dla zachowania kolejności przetwarzania;Mogą być oba. Stateless: filter, map. Stateful: sorted, distinct, limit (muszą znać poprzednie elementy);Wszystkie operacje na streamach są stateless dla zapewnienia thread-safety podczas używania parallel streams w środowisku wielowątkowym;Streamy nie mają w ogóle stanu ponieważ są immutable sequences podobnie jak Stringi i nie przechowują żadnych danych wewnętrznie;1
Na czym polegają operacje intermediate?;Intermediate operations kończą przetwarzanie stream i zwracają końcowy wynik jako Collection, Optional lub primitive value;Intermediate operations zwracają stream i mogą być połączone. Przykład: filter(), map(), flatMap(), distinct(), sorted();Intermediate to tylko map() i filter() zgodnie z definicją functional programming, pozostałe operacje są klasyfikowane jako terminal lub utility;Intermediate operations są deprecated od Java 11 kiedy wprowadzono nową składnię pipeline która zastępuje łańcuchowanie metod;1
Czym jest monada? Podaj przykład w Javie.;Monada to pattern z functional programming który nie ma żadnej implementacji w Java ponieważ język nie wspiera wyższych abstrakcji funkcyjnych;Monada to struktura która opakowuje wartość i dostarcza operacje. Optional<T> jest monadą. Operacje: flatMap (bind), map;Monada to interfejs z pakietu java.util.monad wprowadzony w Java 9 jako część rozszerzenia functional programming capabilities języka;Monada to tylko teoretyczny koncept z matematyki kategorii który nie może być zaimplementowany w języku obiektowym jak Java;1
Na czym polegają operacje terminal?;Terminal operations zwracają nowy stream który może być dalej przetwarzany przez kolejne operacje intermediate lub terminal w nieskończonym łańcuchu;Terminal operations zwracają wynik lub efekt uboczny. Nie zwracają stream. Przykład: collect(), forEach(), reduce(), findFirst(), count();Terminal operations można łączyć w łańcuchy podobnie jak intermediate operations tworząc kompleksowe pipelines przetwarzania danych;Tylko collect() jest prawdziwą terminal operation, pozostałe metody jak forEach() i reduce() są klasyfikowane jako side-effect operations;1
Czym jest funkcja wyższego rzędu? Podaj przykład.;Funkcja która działa znacznie szybciej przez optymalizację JVM oraz używa zaawansowanych algorytmów dla zwiększenia wydajności przetwarzania;Funkcja która przyjmuje funkcję jako argument lub zwraca funkcję. Przykład: Function<Integer, Integer> add = x -> y -> x + y;Funkcja z więcej niż 2 parametrami zgodnie z definicją functional programming gdzie "wyższy rząd" oznacza większą arność;Funkcja która zwraca void i nie ma żadnego return value co czyni ją "wyższym rzędem" w hierarchii side-effects programming;1
Na czym polega optymalizacja stream-ów w Javie?;Optymalizacja przez automatyczne użycie wielowątkowości dla każdego stream bez wyjątku co znacznie przyspiesza przetwarzanie danych;Lazy evaluation, short-circuiting (findFirst() nie przetworzy całego stream), fusion (kombinacja operacji);Optymalizacja przez cache'owanie wyników poprzednich operacji w pamięci oraz reużywanie ich gdy stream jest przetwarzany ponownie;Streamy nie są w ogóle optymalizowane, działają identycznie jak tradycyjne pętle for-each bez żadnych ulepszeń wydajnościowych;1
Czym jest currying? Podaj przykład w Javie.;Currying to deprecated technika z Java 7 która została usunięta w Java 8 ze względu na wprowadzenie lambda expressions jako lepszego rozwiązania;Currying to transformacja funkcji z wieloma argumentami w serię funkcji z jednym. Przykład: (x,y) -> x+y zostaje x -> y -> x+y;Currying to automatyczna optymalizacja lambdów przez kompilator który łączy wiele wywołań funkcji w jedno dla zwiększenia wydajności;Currying to sposób na obsługę wyjątków checked w lambda expressions poprzez wrappowanie ich w unchecked exceptions automatycznie;1
Jak działa operacja filter?;filter(Predicate<T>): zwraca stream elementów spełniających predicate;filter() usuwa wszystkie duplikaty ze streamu podobnie jak operacja distinct() ale z możliwością podania custom predicate dla definicji równości;filter() sortuje elementy według predykatu gdzie true elements są przed false elements w wynikowym streamie posortowanym;filter() jest deprecated od Java 11, należy używać select() zamiast tego dla lepszej czytelności kodu zgodnie z SQL terminology;0
Jak działa operacja map?;map() łączy wiele streamów w jeden duży stream poprzez konkatenację wszystkich elementów ze wszystkich źródłowych streamów;map(Function<T,R>): transformuje każdy element z T na R. Zwraca stream<R>;map() tworzy Map<K,V> ze streamu poprzez użycie elementów jako keys i ich indices jako values w wynikowej strukturze danych;map() filtruje elementy według funkcji która zwraca boolean określający czy element powinien być zachowany w wynikowym streamie;1
Jak działa operacja flatMap?;flatMap() robi dokładnie to samo co map() ale jest szybsza przez wewnętrzną optymalizację JVM dla flat structures;flatMap(Function<T, Stream<R>>): mapuje każdy element na stream i łączy wyniki w jeden stream;flatMap() spłaszcza kolekcje wielopoziomowe do pojedynczych elementów poprzez rekurencyjne rozpakowywanie wszystkich zagnieżdżonych struktur;flatMap() jest używana tylko dla List<List<T>> i nie działa z innymi typami kolekcji ani streamów zagnieżdżonych;1
Czym się różnią operacje map oraz flatMap?;Nie ma żadnej różnicy między nimi, to są tylko synonimy używane zamiennie dla zachowania kompatybilności z różnymi stylami programowania;map: T -> R. flatMap: T -> Stream<R>, wynik jest spłaszczony. Użyj flatMap gdy transformacja tworzy stream;map jest używana dla primitive types jak int, double podczas gdy flatMap jest tylko dla obiektów reference types w streamach;flatMap jest deprecated od Java 11 i nie powinien być używany w nowym kodzie, zamiast tego użyj kombinacji map i reduce;1
Na czym polega operacja reduce?;reduce() redukuje rozmiar streamu przez usuwanie duplikatów oraz elementów null dla optymalizacji pamięci i wydajności przetwarzania;reduce(BinaryOperator<T>): łączy elementy stream w jedną wartość. Przykład: stream.reduce((a,b) -> a+b);reduce() to przestarzała nazwa dla operacji collect() która była używana w wersji beta Java 8 przed ostatecznym wydaniem języka;reduce() działa tylko dla liczb primitive types int, long, double i nie może być używana dla custom objects ze względu na ograniczenia;1
Czym są interfejsy Function oraz BiFunction?;Function to klasa abstrakcyjna nie interfejs funkcyjny która wymaga dziedziczenia oraz implementacji metody abstract R apply(T t) w każdej podklasie;Function<T,R>: T -> R. BiFunction<T,U,R>: (T,U) -> R. Generyczne interfejsy do transformacji;Function i BiFunction są deprecated od Java 11 i zostały zastąpione przez UnaryOperator i BinaryOperator jako lepsze nazwy semantyczne;To klasy konkretne z pakietu java.util.function.impl które są instancjonowane jako new Function<String,Integer>() z implementacją w konstruktorze;1
