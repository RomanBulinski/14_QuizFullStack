Pytanie;Opcja0;Opcja1;Opcja2;Opcja3;indeks_poprawnej
Czym jest interfejs funkcyjny?;Interfejs z dokładnie jedną abstrakcyjną metodą (SAM). Może mieć domyślne metody i statyczne;Interfejs który implementuje Function<T,R>;Interfejs bez żadnych metod używany jako marker;Interfejs z adnotacją @FunctionalInterface który może mieć dowolną liczbę metod;0
Czy interfejs funkcyjny może mieć wiele metod?;Tak, może mieć dowolną liczbę metod;Nie, funkcyjny interfejs może mieć tylko jedną abstrakcyjną metodę. Ale może mieć domyślne i statyczne;Może mieć maksymalnie 3 metody;Od Java 11 może mieć wiele metod;1
Czym są interfejsy Predicate oraz BiPredicate?;Predicate<T>: T -> boolean. BiPredicate<T, U>: (T, U) -> boolean. Używane do testowania warunków w streamach;Predicate to przestarzała nazwa dla Function. BiPredicate nie istnieje;Predicate: T -> T. BiPredicate: (T, U) -> (T, U) do transformacji;Predicate to klasa abstrakcyjna nie interfejs;0
Czym są interfejsy Consumer oraz BiConsumer?;Consumer<T>: T -> void. BiConsumer<T, U>: (T, U) -> void. Używane do wykonania operacji na elementach;Consumer: T -> T do konsumpcji wartości. BiConsumer podobnie;Consumer to deprecated interfejs z Java 7;Consumer i BiConsumer to klasy nie interfejsy;0
Czym jest wyrażenie lambda?;Lambda to klasa anonimowa zapisana w krótszej formie;Lambda (Java 8+) to anonimowa funkcja. Syntax: (params) -> body. Przykład: (x, y) -> x + y;Lambda to metoda statyczna którą można przekazywać;Lambda to przestarzała feature zastąpiona przez method references;1
Jakie znasz interfejsy z pakietu java.util.function?;Function<T,R>, Predicate<T>, Consumer<T>, Supplier<T>, BiFunction<T,U,R>. Stanowią standardowe interfejsy funkcyjne dla lambdów;Lambda, Stream, Optional, Collector jako główne interfejsy;Map, Filter, Reduce, Collect jako interfejsy funkcyjne;Tylko Function<T,R>, reszta jest w java.util.stream;0
Czym jest method reference?;Method reference to deprecated składnia dla lambdów;Method reference to skrót do wyrażenia lambda które wywoła istniejącą metodę. Syntax: Class::method. Przykład: String::toUpperCase;Method reference to sposób na tworzenie metod generycznych;Method reference działa tylko dla metod statycznych;1
Czym są nieskończone stream-y i jak na nich operować?;Nieskończone streamy są niemożliwe w Java;Stream.generate(() -> value) lub Stream.iterate(start, func). Muszą być ograniczane za pomocą limit() lub findFirst();Wszystkie streamy są domyślnie nieskończone;Nieskończone streamy wymagają @Infinite adnotacji;1
Czy lambda może wyrzucić wyjątek?;Tak, lambda może wyrzucać dowolne wyjątki;Jeśli wyjątek jest checked, nie bezpośrednio. Musisz go wrappować lub użyć custom functional interface z throws;Lambda nigdy nie może wyrzucać wyjątków;Tylko RuntimeException może być wyrzucany z lambdów;1
Czym są collectory dla stream-ów?;Collectory to deprecated mechanizm z Java 8;Collectory transformują elementy stream do Collections. Przykład: Collectors.toList(), groupingBy(), joining();Collectory to interfejsy funkcyjne do zbierania danych;Collectory działają tylko dla parallel streams;1
Jak obsłużyć wyjątki checked w przypadku wyrażeń lambda?;Checked wyjątki są automatycznie konwertowane na unchecked;Wrappuj wyjątek w unchecked Exception lub utwórz custom functional interface. Przykład: e -> { try { } catch(...) {} };Nie można obsługiwać checked wyjątków w lambda;Używaj @CheckedLambda adnotacji;1
Jakie zalety mają stream-y?;Tylko wydajność jest zaletą streamów;Deklaratywne (co chcesz nie jak), lazy evaluation, łatwo paralelizować, readable, functional programming;Streamy są zawsze szybsze od pętli;Główna zaleta to automatyczne zamykanie zasobów;1
Czym jest Optional? Gdzie się go w praktyce używa?;Optional to kontener dla kolekcji elementów;Optional<T> to kontener który może zawierać wartość lub być pusty. Używany zamiast null. Metody: isPresent(), get(), orElse(), map();Optional to przestarzały mechanizm z Java 8;Optional działa tylko ze streamami;1
Czy stream-y są lazy?;Nie, wszystkie operacje wykonują się natychmiast;Tak, operacje intermediate (map, filter) nie są wykonywane aż do terminal operation (collect, forEach);Tylko parallel streams są lazy;Stream-y są lazy tylko w Java 11+;1
Czym jest stream?;Stream to kolekcja która przechowuje dane w pamięci;Stream to sekwencja elementów z funkcyjnymi operacjami. Nie przechowuje danych, operuje na źródle;Stream to deprecated nazwa dla Iterator;Stream to interfejs dla I/O operacji;1
Czy stream-y są stateful czy stateless?;Wszystkie operacje są stateful;Mogą być oba. Stateless: filter, map. Stateful: sorted, distinct, limit (muszą znać poprzednie elementy);Wszystkie operacje są stateless dla thread-safety;Streamy nie mają stanu w ogóle;1
Na czym polegają operacje intermediate?;Intermediate operations kończą stream;Intermediate operations zwracają stream i mogą być połączone. Przykład: filter(), map(), flatMap(), distinct(), sorted();Intermediate to tylko map() i filter();Intermediate operations są deprecated;1
Czym jest monada? Podaj przykład w Javie.;Monada to pattern z functional programming bez implementacji w Java;Monada to struktura która opakowuje wartość i dostarcza operacje. Optional<T> jest monadą. Operacje: flatMap (bind), map;Monada to interfejs z pakietu java.util.monad;Monada to tylko teoretyczny koncept;1
Na czym polegają operacje terminal?;Terminal operations zwracają nowy stream;Terminal operations zwracają wynik lub efekt uboczny. Nie zwracają stream. Przykład: collect(), forEach(), reduce(), findFirst(), count();Terminal operations można łączyć w łańcuchy;Tylko collect() jest terminal operation;1
Czym jest funkcja wyższego rzędu? Podaj przykład.;Funkcja która działa szybciej przez optymalizację;Funkcja która przyjmuje funkcję jako argument lub zwraca funkcję. Przykład: Function<Integer, Integer> add = x -> y -> x + y;Funkcja z więcej niż 2 parametrami;Funkcja która zwraca void;1
Na czym polega optymalizacja stream-ów w Javie?;Optymalizacja przez użycie wielowątkowości zawsze;Lazy evaluation, short-circuiting (findFirst() nie przetworzy całego stream), fusion (kombinacja operacji);Optymalizacja przez cache'owanie wyników;Streamy nie są optymalizowane;1
Czym jest currying? Podaj przykład w Javie.;Currying to deprecated technika z Java 7;Currying to transformacja funkcji z wieloma argumentami w serię funkcji z jednym. Przykład: (x,y) -> x+y zostaje x -> y -> x+y;Currying to optymalizacja lambdów przez kompilator;Currying to sposób na obsługę wyjątków w lambda;1
Jak działa operacja filter?;filter(Predicate<T>): zwraca stream elementów spełniających predicate;filter() usuwa duplikaty ze streamu;filter() sortuje elementy według predykatu;filter() jest deprecated, używaj select();0
Jak działa operacja map?;map() łączy wiele streamów w jeden;map(Function<T,R>): transformuje każdy element z T na R. Zwraca stream<R>;map() tworzy Map<K,V> ze streamu;map() filtruje elementy według funkcji;1
Jak działa operacja flatMap?;flatMap() robi to samo co map() ale szybciej;flatMap(Function<T, Stream<R>>): mapuje każdy element na stream i łączy wyniki w jeden stream;flatMap() spłaszcza kolekcje do pojedynczych elementów;flatMap() jest tylko dla List<List<T>>;1
Czym się różnią operacje map oraz flatMap?;Nie ma różnicy, to synonimy;map: T -> R. flatMap: T -> Stream<R>, wynik jest spłaszczony. Użyj flatMap gdy transformacja tworzy stream;map dla primitive types, flatMap dla obiektów;flatMap jest deprecated;1
Na czym polega operacja reduce?;reduce() redukuje rozmiar streamu przez usuwanie elementów;reduce(BinaryOperator<T>): łączy elementy stream w jedną wartość. Przykład: stream.reduce((a,b) -> a+b);reduce() to przestarzała nazwa dla collect();reduce() działa tylko dla liczb;1
Czym są interfejsy Function oraz BiFunction?;Function to klasa abstrakcyjna nie interfejs;Function<T,R>: T -> R. BiFunction<T,U,R>: (T,U) -> R. Generyczne interfejsy do transformacji;Function i BiFunction są deprecated od Java 11;To klasy z pakietu java.util.function.impl;1
