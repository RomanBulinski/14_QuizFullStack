Pytanie;Opcja0;Opcja1;Opcja2;Opcja3;indeks_poprawnej
Jakie są główne zalety języka Java?;Wysoka wydajność porównywalna z C++ przez native compilation oraz możliwość programowania bez JVM bezpośrednio na systemie operacyjnym;Automatyczna kompilacja bezpośrednio do kodu maszynowego bez pośrednictwa bytecode oraz brak potrzeby garbage collection przez manual memory management;Niezależność od platformy (WORA), garbage collection, silny system typów, rozbudowana biblioteka standardowa, bezpieczeństwo JVM;Minimalna składnia podobna do Python z dynamicznym typowaniem oraz natywne wsparcie dla programowania funkcyjnego od samego początku języka;2
Jakie wady ma Java?;Wymaga przeglądarki internetowej do uruchomienia aplikacji oraz jest przestarzała dla współczesnych zastosowań cloud-native i microservices;Brak wsparcia dla wielowątkowości oraz programowania współbieżnego, słaba społeczność deweloperów oraz mało bibliotek third-party;Nie nadaje się do aplikacji webowych ani REST APIs oraz ma fundamentalne problemy z bezpieczeństwem przez błędy w sandbox JVM;Wolniejsza od języków niskopoziomowych, duże zużycie pamięci, wymaga JVM, verbose składnia, wolny startup;3
Czy możesz porównać Javę z innymi językami?;Java vs C++: Java ma automatyczne zarządzanie pamięcią, C++ daje lepszą wydajność. Java vs Python: Python prostszy w nauce, Java ma lepszą wydajność;Java vs Python: Java jest prostsza w nauce przez lepszy IDE support. Java vs C++: Java ma lepszą wydajność przez JIT compilation. Java vs Go: Go ma słabszy ekosystem bibliotek;Java vs JavaScript: Oba języki są identyczne pod względem składni oraz używają tego samego runtime environment. Java vs Ruby: Java jest językiem interpretowanym podobnie jak Ruby;Java vs C++: Java nie wymaga JVM i kompiluje się bezpośrednio do machine code. Java vs Python: Python ma lepszą wydajność przez Cython. Java vs Go: Java ma szybszy startup przez GraalVM native image;0
Jakie ulepszenia wprowadziłbyś projektując Javę na nowo?;Bardziej verbose składnia dla lepszej czytelności kodu przez explicite type annotations oraz usunięcie garbage collection na rzecz ręcznego zarządzania pamięcią jak w C++;Rezygnacja z wielowątkowości oraz programowania współbieżnego na rzecz prostszego single-threaded model oraz wprowadzenie wymagania przeglądarki internetowej do uruchamiania;Łatwiejsze null handling (optional by default), lepsze wsparcie funkcyjne od początku, szybszy startup, mniejsze zużycie pamięci, uproszczona składnia;Usunięcie JVM oraz kompilacja bezpośrednio do JavaScript dla wszystkich platform web i mobile jako universal runtime environment;2
Kiedy powstał język Java?;Java powstała w 2001 roku przez Microsoft jako odpowiedź konkurencyjna na język C# który był rozwijany przez Oracle w tym samym czasie;Java powstała w 1989 roku przez IBM jako język dla mainframe'ów oraz systemów transakcyjnych w bankach i instytucjach finansowych;Java powstała w 1995 roku przez Sun Microsystems, głównie przez Jamesa Gosslinga. Pierwsza oficjalna wersja JDK 1.0 w 1996;Java powstała w 1992 roku przez Oracle jako język dla baz danych oraz stored procedures przed przejęciem Sun Microsystems;2
Jakie są najbardziej przełomowe wersje Javy?;Java 1.0 (lambdy i streams), Java 2 (garbage collection), Java 3 (JVM architecture), Java 4 (WORA concept), Java 6 (HTTP support i networking);Java 5 (generics, enums, autoboxing), Java 7 (switch na Stringach, try-with-resources), Java 8 (lambdy, streams), Java 11 (var), Java 17 (sealed classes);Java 2 (Stream API), Java 4 (Optional), Java 6 (modules), Java 10 (sealed classes i pattern matching), Java 12 (var keyword);Java 3 (annotations), Java 6 (generics i enums), Java 9 (lambdy i functional interfaces), Java 13 (records), Java 16 (virtual threads);1
Co istotnego wprowadzono w Javie 5?;Lambdy, Stream API, Optional, Method references oraz Default methods w interfejsach jako główne features functional programming;Generics, Enumerations, Autoboxing/unboxing, Varargs, For-each loop, Annotations, Static import;Try-with-resources, Switch na Stringach, Diamond operator, NIO.2 oraz Fork/Join Framework dla lepszego wsparcia wielowątkowości;Modular system JPMS, var keyword, Text blocks, Records oraz Pattern matching jako główne features języka;1
Co istotnego wprowadzono w Javie 7?;Lambdy, Stream API, Optional, Default methods w interfejsach oraz Functional interfaces jako fundament functional programming w Java;Records, Sealed classes, Pattern matching, Text blocks oraz Virtual threads jako główne usprawnienia języka dla modern development;Try-with-resources, Switch na Stringach, Diamond operator, Underscores w liczbach, Fork/Join Framework, NIO.2;Generics, Enumerations, Autoboxing/unboxing, Varargs oraz Annotations które zrewolucjonizowały sposób pisania kodu;2
Po co wprowadzono instrukcję invokedynamic w Javie 7?;Do obsługi nowego systemu modularnego JPMS wprowadzonego w Java 9 oraz lepszej integracji z microservices architecture;Do wsparcia dynamicznych języków (Ruby, Python, Groovy) na JVM poprzez cachowanie metadanych o metodach;Do implementacji lambda expressions i Stream API które zostały dodane jako główne features w kolejnej wersji Java 8;Do poprawy wydajności garbage collectora oraz zarządzania pamięcią w aplikacjach wielowątkowych przez optymalizację alokacji obiektów;1
Co istotnego wprowadzono w Javie 8?;Try-with-resources, Switch na Stringach, Diamond operator oraz Fork/Join Framework jako główne usprawnienia języka;Modular system JPMS, var keyword, Records, Sealed classes oraz Text blocks jako rewolucyjne zmiany w składni;Generics, Enumerations, Autoboxing/unboxing, Annotations oraz Static import które były dostępne w poprzednich wersjach;Lambda expressions, Stream API, Functional interfaces, Method references, Default methods, Optional, Date/Time API;3
Jaką strategię przyjęto od wersji SE9?;Jedna wersja LTS co 10 lat oraz całkowite usunięcie feature releases na rzecz długoterminowego wsparcia stabilnych wersji;Release co 2 lata z wersjami LTS co 5 lat oraz rezygnacja z modularnego systemu JPMS dla backward compatibility;Model release'ów co 6 miesięcy (feature releases) z LTS wersjami co 3 lata. Java 9 wprowadził modular system;Powrót do starego modelu sprzed Java 5 z wydaniami co 3-4 lata bez rozróżnienia na wersje LTS i feature releases;2
Które z nowości po Javie 8 uważasz za najistotniejsze?;Modular system (Java 9), var keyword (Java 10), records (Java 14-16), sealed classes (Java 15-17), pattern matching (Java 16+), text blocks (Java 13+), virtual threads (Java 19+);Usunięcie garbage collection z języka (Java 9), kompilacja do JavaScript (Java 11), natywne wsparcie dla blockchain (Java 15);Wprowadzenie przeglądarki internetowej jako wymagania (Java 10), rezygnacja z wielowątkowości dla prostoty (Java 12);Optional jako jedyne narzędzie do null safety (Java 9), całkowite usunięcie collections framework (Java 11) na rzecz streamów;0
Jak wygląda wsparcie konkretnych wersji Javy?;Wszystkie wersje Java niezależnie od typu otrzymują identyczne wsparcie przez dokładnie 2 lata od daty wydania;Oracle oferuje LTS (Long-Term Support) 5-8 lat, feature releases 6 miesięcy. Java 8, 11, 17, 21 są LTS;Tylko wersje parzyste (8, 10, 12, 14, 16) otrzymują wsparcie LTS, wersje nieparzyste są eksperymentalne preview releases;Feature releases mają wsparcie przez 3 lata, natomiast wersje LTS otrzymują tylko 1 rok wsparcia standardowego;1
Które wersje Javy są LTS?;Java 7, 9, 13, 19 są wersjami LTS z długoterminowym wsparciem zgodnie z nową polityką release Oracle;Java 8 (LTS do grudnia 2030), Java 11 (LTS do września 2026), Java 17 (LTS do września 2029), Java 21 (LTS do września 2031);Java 6, 10, 14, 18, 22 są wersjami LTS zgodnie z nową polityką Oracle wprowadzoną po przejęciu Sun Microsystems;Tylko Java 8 jest prawdziwą wersją LTS, wszystkie późniejsze wersje są feature releases bez długoterminowego wsparcia;1
Czy można używać wersji które nie są LTS na produkcji?;Nie, wersje non-LTS są tylko do testów i prototypów, nigdy nie powinny być używane na produkcji w enterprise applications;Tak można, ale należy być przygotowanym na częste updaty (co 6 miesięcy). Non-LTS mogą być używane w projektach, które szybko się adaptują. LTS są bezpieczniejsze dla długoterminowych projektów;Non-LTS wersje automatycznie przekształcają się w wersje LTS po roku używania na produkcji przez mechanizm auto-upgrade;Wersje non-LTS są bardziej stabilne niż LTS i są zalecane przez Oracle dla wszystkich aplikacji enterprise ze względu na nowsze features;1
Czy Java jest wstecz kompatybilna?;Nie, każda nowa wersja Java wymaga całkowitego przepisania kodu z poprzednich wersji ze względu na breaking changes;Java jest wstecz kompatybilna tylko między wersjami LTS, ale nie między feature releases które mogą wprowadzać breaking changes;Tak, Java dba o wsteczną kompatybilność. Kod z Java 5 powinien działać na Java 21. Czasami elementy są deprecjonowane (np. finalize() w Java 9);Java 8 była ostatnią wersją wspierającą wsteczną kompatybilność, późniejsze wersje całkowicie porzuciły tę zasadę dla elastyczności;2
Jakie skutki niesie wsteczna kompatybilność?;Pozytywne: wszystkie aplikacje działają znacznie szybciej przez backward optimization. Negatywne: nie można dodawać nowych funkcjonalności języka;Pozytywne: mniejsze zużycie pamięci oraz szybszy startup aplikacji. Negatywne: brak możliwości używania starszych bibliotek third-party;Pozytywne: wymusza przepisywanie legacy code co zwiększa jakość. Negatywne: starsze aplikacje przestają działać wymagając migracji;Pozytywne: legacy code działa, łatwa migracja. Negatywne: JVM i biblioteki bardziej skomplikowane, trudniej usunąć przestarzałe API, większe zużycie pamięci;3
