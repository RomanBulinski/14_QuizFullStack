Pytanie;Opcja0;Opcja1;Opcja2;Opcja3;indeks_poprawnej
Czym jest java.lang.Object i co go rozszerza?;Object to interfejs bazowy dla wszystkich interfejsów w Java;Object to klasa bazowa dla wszystkich klas w Javie. Każda klasa (bezpośrednio lub pośrednio) dziedziczy Object;Object to abstract class którą można opcjonalnie rozszerzać;Object to przestarzała klasa zastąpiona przez BaseClass w Java 9;1
Jakie metody są dostępne w klasie Object?;clone(), equals(), finalize(), getClass(), hashCode(), notify(), notifyAll(), toString(), wait();toString(), valueOf(), parse(), format(), compare(), create(), destroy();init(), destroy(), serialize(), deserialize(), copy(), compare();new(), delete(), allocate(), free(), lock(), unlock();0
Dlaczego finalize jest oznaczone jako deprecated?;finalize() jest deprecated bo został zastąpiony przez close() w Java 8;finalize() (Java 9+) jest deprecated bo nie gwarantuje czasowego wykonania, jest mało niezawodny, GC nie jest przewidywalny. Używaj try-with-resources;finalize() powodował memory leaki i został usunięty całkowicie;finalize() działa poprawnie ale zmieniono nazwę na finalizeObject();1
Czy używanie metody clone to dobra praktyka?;Tak, clone() jest najszybszą metodą kopiowania obiektów;clone() jest dobrą praktyką tylko dla immutable objects;Nie. clone() jest problematyczny (shallow copying, wymaga Cloneable). Lepsze: copy constructor, builder, copy factory method;clone() jest obowiązkowy dla wszystkich klas implementujących Serializable;2
Co zwraca domyślnie toString()?;toString() zwraca JSON reprezentację obiektu;toString() zwraca wszystkie pola obiektu w formacie key=value;Domyślnie toString() zwraca: NazwaKlasy@hashCode. Powinno się nadpisać dla znaczącego opisu;toString() zwraca identyczny wynik jak getClass().getName();2
Na czym polega kontrakt equals-hashCode?;Jeśli hashCode równe to equals musi zwrócić true;Jeśli equals zwraca false to hashCode musi być różne;Jeśli dwa obiekty są równe (equals() true), to muszą mieć taki sam hashCode(). Odwrotnie nie musi być prawda;equals i hashCode muszą zawsze zwracać różne wartości dla różnych obiektów;2
Czy można nadpisać samą metodę equals() bez hashCode()?;Tak, to jest zalecane gdy nie używamy obiektów w kolekcjach;Nie, kompilator nie pozwoli na kompilację gdy brakuje hashCode;Technicznie tak ale narusza kontrakt equals-hashCode. Spowoduje problemy w HashMap czy HashSet;Tak, hashCode() jest automatycznie generowany na podstawie equals();2
Czy można nadpisać samą metodę hashCode() bez equals()?;Tak, hashCode() nie wymaga equals() i są niezależne;Nie, equals() musi być zawsze nadpisany pierwszy;Technicznie tak ale też narusza kontrakt. Powoduje problemy z porównywaniem obiektów;Tak ale tylko dla klas immutable;2
Jakie właściwości powinny posiadać nadpisane equals() oraz hashCode()?;equals: faster than hashCode. hashCode: unique dla każdego obiektu;equals(): reflexive (x.equals(x)=true), symmetric, transitive, consistent. hashCode(): spójny z equals(), równomiernie rozłożony;equals: może zwracać różne wyniki przy każdym wywołaniu dla elastyczności;hashCode: musi być unique dla każdej instancji, equals: może używać ==;1
Kiedy warto nadpisywać metody equals() oraz hashCode()?;Zawsze dla każdej klasy jako best practice;Nigdy, domyślne implementacje są zawsze wystarczające;Gdy klasa używana jako klucz w Map lub element w Set. Gdy równość ma znaczenie dla domeny (value objects, DTO);Tylko dla klas abstrakcyjnych i interfejsów;2
Jakie są pożądane cechy dobrej wartości hashCode()?;hashCode powinien zawsze zwracać 0 dla prostoty;Równomiernie rozłożona, szybka do obliczenia, spójna z equals(), zmienia się jeśli zmienią się istotne pola;hashCode powinien być unikalny dla każdego obiektu w JVM;hashCode powinien być obliczany raz i cache'owany na zawsze;1
Jak nadpisać equals/hashCode w przypadku dziedziczenia?;Nie można nadpisywać tych metod w podklasach;Ignoruj pola z klasy nadrzędnej, użyj tylko pola z podklasy;W podklasie wywołaj super.equals() i super.hashCode(). Upewnij się że porównujesz pola z nadrzędnej i podklasy;Użyj reflection API do porównania wszystkich pól automatycznie;2
Czy można sprawdzać równość obiektów przez operator ==?;Tak, == i equals() są identyczne w działaniu;Nie, == jest deprecated i nie powinien być używany;== porównuje referencje nie zawartość. Dla obiektów użyj equals(). == może być dla typów prostych;== działa tylko dla String, dla innych obiektów użyj equals();2
