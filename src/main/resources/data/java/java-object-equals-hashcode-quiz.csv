Pytanie;Opcja0;Opcja1;Opcja2;Opcja3;indeks_poprawnej
Czym jest java.lang.Object i co go rozszerza?;Object to interfejs bazowy dla wszystkich interfejsów w Java który definiuje podstawowe metody dostępne dla wszystkich typów;Object to klasa bazowa dla wszystkich klas w Javie. Każda klasa (bezpośrednio lub pośrednio) dziedziczy Object;Object to abstract class którą można opcjonalnie rozszerzać jeśli klasa potrzebuje podstawowych metod jak equals i toString;Object to przestarzała klasa która została zastąpiona przez BaseClass w Java 9 dla lepszej czytelności oraz spójności nazewnictwa;1
Jakie metody są dostępne w klasie Object?;clone(), equals(), finalize(), getClass(), hashCode(), notify(), notifyAll(), toString(), wait();toString(), valueOf(), parse(), format(), compare(), create(), destroy() jako główne metody utility dostępne dla wszystkich obiektów;init(), destroy(), serialize(), deserialize(), copy(), compare() dla zarządzania cyklem życia obiektów w aplikacjach Java;new(), delete(), allocate(), free(), lock(), unlock() do zarządzania pamięcią oraz synchronizacją dostępu wielowątkowego;0
Dlaczego finalize jest oznaczone jako deprecated?;finalize() jest deprecated bo został całkowicie zastąpiony przez metodę close() wprowadzoną w Java 8 jako część interfejsu AutoCloseable;finalize() (Java 9+) jest deprecated bo nie gwarantuje czasowego wykonania, jest mało niezawodny, GC nie jest przewidywalny. Używaj try-with-resources;finalize() powodował memory leaki przez błędy w implementacji garbage collectora i został całkowicie usunięty z języka Java;finalize() działa poprawnie ale nazwa została zmieniona na finalizeObject() w Java 11 dla lepszej czytelności kodu;1
Czy używanie metody clone to dobra praktyka?;Tak, clone() jest najszybszą metodą kopiowania obiektów przez bezpośrednie kopiowanie pamięci na poziomie natywnym JVM;clone() jest dobrą praktyką tylko dla immutable objects które nie mają referencji do innych obiektów w swoich polach;Nie. clone() jest problematyczny (shallow copying, wymaga Cloneable). Lepsze: copy constructor, builder, copy factory method;clone() jest obowiązkowy dla wszystkich klas implementujących Serializable zgodnie z kontraktem interfejsu Serializable w Java;2
Co zwraca domyślnie toString()?;toString() zwraca automatycznie wygenerowaną JSON reprezentację wszystkich pól obiektu w formacie klucz-wartość;toString() zwraca wszystkie pola obiektu w formacie key=value oddzielone przecinkami przez reflection API skanujące strukturę;Domyślnie toString() zwraca: NazwaKlasy@hashCode. Powinno się nadpisać dla znaczącego opisu;toString() zwraca identyczny wynik jak getClass().getName() plus dodatkowy timestamp utworzenia obiektu w formacie ISO;2
Na czym polega kontrakt equals-hashCode?;Jeśli hashCode są równe to equals musi zawsze zwrócić true zgodnie z matematyczną definicją funkcji hashującej;Jeśli equals zwraca false to hashCode musi być różne dla obu obiektów w przeciwnym razie następuje naruszenie kontraktu;Jeśli dwa obiekty są równe (equals() true), to muszą mieć taki sam hashCode(). Odwrotnie nie musi być prawda;equals i hashCode muszą zawsze zwracać różne wartości dla różnych instancji obiektów niezależnie od zawartości pól;2
Czy można nadpisać samą metodę equals() bez hashCode()?;Tak, to jest zalecane gdy nie używamy obiektów w kolekcjach hash-based jak HashMap czy HashSet dla uproszczenia;Nie, kompilator nie pozwoli na kompilację gdy brakuje nadpisanej metody hashCode() zgodnie z kontraktem equals-hashCode;Technicznie tak ale narusza kontrakt equals-hashCode. Spowoduje problemy w HashMap czy HashSet;Tak, hashCode() jest automatycznie generowany przez JVM na podstawie implementacji equals() bez konieczności ręcznego nadpisywania;2
Czy można nadpisać samą metodę hashCode() bez equals()?;Tak, hashCode() nie wymaga equals() ponieważ są to niezależne metody używane w różnych kontekstach aplikacyjnych;Nie, equals() musi być zawsze nadpisany pierwszy przed nadpisaniem hashCode() zgodnie z kolejnością w kontrakcie Object;Technicznie tak ale też narusza kontrakt. Powoduje problemy z porównywaniem obiektów;Tak ale tylko dla klas immutable które nie będą używane jako klucze w HashMap ani elementy w HashSet;2
Jakie właściwości powinny posiadać nadpisane equals() oraz hashCode()?;equals: faster than hashCode dla optymalizacji. hashCode: unique dla każdego obiektu w JVM dla zapewnienia unikalności;equals(): reflexive (x.equals(x)=true), symmetric, transitive, consistent. hashCode(): spójny z equals(), równomiernie rozłożony;equals: może zwracać różne wyniki przy każdym wywołaniu dla tego samego obiektu dla elastyczności implementacji;hashCode: musi być unique dla każdej instancji obiektu. equals: może używać == dla porównania referencji jako optymalizacja;1
Kiedy warto nadpisywać metody equals() oraz hashCode()?;Zawsze dla każdej klasy jako best practice zgodnie z zaleceniami Oracle w dokumentacji Java API niezależnie od użycia;Nigdy nie ma potrzeby, domyślne implementacje dziedziczone z Object są zawsze wystarczające dla wszystkich przypadków użycia;Gdy klasa używana jako klucz w Map lub element w Set. Gdy równość ma znaczenie dla domeny (value objects, DTO);Tylko dla klas abstrakcyjnych i interfejsów które definiują kontrakt równości dla swoich implementacji konkretnych;2
Jakie są pożądane cechy dobrej wartości hashCode()?;hashCode powinien zawsze zwracać stałą wartość 0 dla wszystkich obiektów dla prostoty implementacji oraz łatwości debugowania;Równomiernie rozłożona, szybka do obliczenia, spójna z equals(), zmienia się jeśli zmienią się istotne pola;hashCode powinien być unikalny dla każdego obiektu w JVM podobnie jak System.identityHashCode() dla zapewnienia unikalności;hashCode powinien być obliczany raz podczas konstrukcji obiektu i cache'owany na zawsze niezależnie od zmian w polach;1
Jak nadpisać equals/hashCode w przypadku dziedziczenia?;Nie można nadpisywać tych metod w podklasach ze względu na naruszenie Liskov Substitution Principle w hierarchii dziedziczenia;Ignoruj wszystkie pola z klasy nadrzędnej, użyj tylko pola zdefiniowane bezpośrednio w podklasie dla uproszczenia logiki;W podklasie wywołaj super.equals() i super.hashCode(). Upewnij się że porównujesz pola z nadrzędnej i podklasy;Użyj reflection API do automatycznego porównania wszystkich pól włącznie z унаследованymi bez ręcznego wywoływania super;2
Czy można sprawdzać równość obiektów przez operator ==?;Tak, operator == i metoda equals() są identyczne w działaniu dla wszystkich typów obiektów w Java;Nie, operator == jest deprecated i nie powinien być używany w nowoczesnym kodzie Java od wersji 8 wzwyż;== porównuje referencje nie zawartość. Dla obiektów użyj equals(). == może być dla typów prostych;== działa tylko dla String przez String Pool optimization, dla innych obiektów zawsze użyj metody equals();2
