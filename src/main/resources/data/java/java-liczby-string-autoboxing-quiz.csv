Pytanie;Opcja0;Opcja1;Opcja2;Opcja3;indeks_poprawnej
Jaka jest reprezentacja liczb całkowitych w Javie?;Liczby całkowite używają BCD (Binary Coded Decimal) dla dokładności;Liczby całkowite (byte, short, int, long) w systemie dwójkowym (two's complement). byte (-128 do 127), int (-2^31 do 2^31-1);Wszystkie liczby całkowite są 64-bitowe dla spójności;Liczby używają floating point dla elastyczności zakresu;1
Jaka jest reprezentacja liczb zmiennoprzecinkowych w Javie?;Liczby zmiennoprzecinkowe używają własnego formatu Oracle Floating Point;Liczby zmiennoprzecinkowe (float, double) używają IEEE 754. float: 32-bit (6-7 cyfr), double: 64-bit (15-17 cyfr);float i double są identyczne, double to tylko alias dla kompatybilności;Liczby zmiennoprzecinkowe używają formatu BigDecimal wewnętrznie;1
Jak pracować z bardzo dużymi liczbami w Javie?;Używaj long long i double double dla większych zakresów;Używaj BigInteger i BigDecimal z java.math. BigInteger dla całkowitych, BigDecimal dla dziesiętnych (dokładne);Java automatycznie promuje typy do większych gdy są za duże;Używaj HugeNumber z pakietu java.lang.huge wprowadzonego w Java 11;1
Czym jest String?;String to tablica char[] z dodatkowymi metodami utility;String to primitive type wprowadzony w Java 5 dla wygody;String to sekwencja znaków (char). String jest immutable - raz stworzony nie może być zmieniony;String to interfejs implementowany przez StringBuilder i StringBuffer;2
Czy String-i można modyfikować?;Tak, używając metod mutujących jak setCharAt();Nie, Stringi są immutable. Operacje na String (concat, replace) tworzą nowe obiekty;Można modyfikować przez reflection API;Od Java 9 Stringi są mutable dla optymalizacji pamięci;1
Jak działa operator + w przypadku String-ów?;+ zawsze wywołuje concat() która jest szybsza niż StringBuilder;+ konkatenuje Stringi. Jeśli jeden operand jest String, drugi konwertowany na String (toString());+ działa tylko dla String literalów, dla zmiennych trzeba użyć concat();+ jest deprecated, należy używać String.join() zamiast;1
Czy String jest obiektem?;Nie, String jest primitive type jak int czy char;Tak, String jest obiektem klasy java.lang.String;String jest special type który zachowuje się jak primitive ale jest obiektem;String był obiektem do Java 8, potem stał się primitive dla wydajności;1
Co oznacza że String jest immutable?;String jest final więc nie może być dziedziczony;String może być modyfikowany tylko przez własne metody nie przez zewnętrzny kod;String nie może być zmieniony po utworzeniu. Każda operacja tworzy nowy String. Bezpieczne dla wątków;String cache'uje wartości więc modyfikacje są ignorowane dla wydajności;2
Jak skonwertować String na liczbę?;Integer.parseInt("123"), Integer.valueOf("123"), Long.parseLong(), Double.parseDouble(). Rzuca NumberFormatException;Używając (int)"123" lub (Integer)"123" przez rzutowanie;String.toInteger(), String.toLong(), String.toDouble();Integer.convert("123"), automatyczna konwersja przez autoboxing;0
Jaka jest różnica między rzutowaniem a parsowaniem?;Rzutowanie i parsowanie to synonimy w Java;Parsowanie działa tylko dla String, rzutowanie dla wszystkich typów;Rzutowanie to konwersja między typami (typ1) wartość. Parsowanie to konwersja String na inny typ (Integer.parseInt());Rzutowanie jest szybsze, parsowanie bezpieczniejsze ale wolniejsze;2
Jak konkatenować String-i w pętli aby było wydajne?;Używaj String += w pętli, kompilator automatycznie optymalizuje;Użyj StringBuilder (nie synchronized) zamiast +. StringBuilder.append() i toString() na końcu;Używaj String.concat() w każdej iteracji;StringBuffer jest zawsze szybszy od StringBuilder w pętlach;1
Czym jest StringBuilder i jakie ma wady/zalety?;StringBuilder to immutable klasa dla thread-safety;StringBuilder to mutable sekwencja znaków (od Java 5). Zalety: wydajny, nie synchronized. Wady: mutable (nie thread-safe);StringBuilder jest synchronized więc bezpieczny wielowątkowo;StringBuilder został zastąpiony przez StringJoiner w Java 8;1
Czym jest StringBuffer i jakie ma wady/zalety?;StringBuffer to nowoczesna wersja StringBuilder z Java 8;StringBuffer to mutable sekwencja znaków (przed Java 5). Zalety: thread-safe (synchronized). Wady: wolniejszy niż StringBuilder;StringBuffer nie jest synchronized, to StringBuilder jest;StringBuffer i StringBuilder są identyczne, różnica tylko w nazwie;1
Co to jest autoboxing i jaki jest tego cel?;Autoboxing to optymalizacja JVM dla typów prostych w kolekcjach;Autoboxing (Java 5+) to automatyczna konwersja między prostymi a wrapper klasami (int <-> Integer). Cel: wygoda, użycie w Collections;Autoboxing to cache'owanie wrapper objects dla wydajności;Autoboxing to przestarzały mechanizm zastąpiony przez var w Java 10;1
Co to jest unboxing i po co jest potrzebne?;Unboxing to usuwanie obiektów z Boxa (Collection wrapper);Unboxing to automatyczna konwersja wrapper na typ prosty (Integer -> int). Potrzebne bo Collections zawierają tylko obiekty;Unboxing to deserializacja obiektów z formatu binarnego;Unboxing to rozpakowywanie Optional values;1
