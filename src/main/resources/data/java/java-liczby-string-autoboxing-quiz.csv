Pytanie;Opcja0;Opcja1;Opcja2;Opcja3;indeks_poprawnej
Jaka jest reprezentacja liczb całkowitych w Javie?;Liczby całkowite używają BCD (Binary Coded Decimal) dla zwiększenia dokładności obliczeń oraz zapobiegania błędom zaokrągleń w arytmetyce;Liczby całkowite (byte, short, int, long) w systemie dwójkowym (two's complement). byte (-128 do 127), int (-2^31 do 2^31-1);Wszystkie liczby całkowite są automatycznie konwertowane do 64-bitowego formatu long dla spójności operacji arytmetycznych w JVM;Liczby używają floating point wewnętrznie dla elastyczności zakresu oraz możliwości reprezentowania wartości dziesiętnych gdy jest to potrzebne;1
Jaka jest reprezentacja liczb zmiennoprzecinkowych w Javie?;Liczby zmiennoprzecinkowe używają własnego formatu Oracle Floating Point który zapewnia lepszą precyzję niż standardowy IEEE 754;Liczby zmiennoprzecinkowe (float, double) używają IEEE 754. float: 32-bit (6-7 cyfr), double: 64-bit (15-17 cyfr);float i double są identyczne pod względem reprezentacji, double to tylko alias dla kompatybilności z kodem napisanym przed Java 5;Liczby zmiennoprzecinkowe używają formatu BigDecimal wewnętrznie dla zapewnienia maksymalnej precyzji oraz unikania błędów zaokrągleń;1
Jak pracować z bardzo dużymi liczbami w Javie?;Używaj long long i double double dla większych zakresów wartości które przekraczają standardowe limity typów prostych w Java;Używaj BigInteger i BigDecimal z java.math. BigInteger dla całkowitych, BigDecimal dla dziesiętnych (dokładne);Java automatycznie promuje typy do większych gdy wartości są za duże stosując internal overflow handling mechanism wprowadzony w Java 8;Używaj HugeNumber z pakietu java.lang.huge wprowadzonego w Java 11 dla obsługi liczb przekraczających zakres long i double;1
Czym jest String?;String to tablica char[] z dodatkowymi metodami utility oraz implementacją interfejsu CharSequence dla kompatybilności z legacy code;String to primitive type wprowadzony w Java 5 dla wygody programistów oraz uproszczenia składni porównań przez operator ==;String to sekwencja znaków (char). String jest immutable - raz stworzony nie może być zmieniony;String to interfejs implementowany przez StringBuilder i StringBuffer które dostarczają konkretnych implementacji przechowywania tekstu;2
Czy String-i można modyfikować?;Tak, używając metod mutujących jak setCharAt(), replaceChar() oraz insertAt() dostępnych w klasie String od Java 7;Nie, Stringi są immutable. Operacje na String (concat, replace) tworzą nowe obiekty;Można modyfikować bezpośrednio przez reflection API który pozwala na dostęp do wewnętrznej tablicy char[] i zmianę jej zawartości;Od Java 9 Stringi stały się mutable dla optymalizacji pamięci oraz zwiększenia wydajności operacji na tekstach w aplikacjach;1
Jak działa operator + w przypadku String-ów?;+ zawsze wywołuje metodę concat() która jest znacznie szybsza niż StringBuilder przez wewnętrzną optymalizację JVM dla operacji tekstowych;+ konkatenuje Stringi. Jeśli jeden operand jest String, drugi konwertowany na String (toString());+ działa tylko dla String literalów zdefiniowanych w kodzie, dla zmiennych String trzeba użyć metody concat() lub StringBuilder.append();+ jest deprecated od Java 11, należy używać String.join() zamiast tego dla lepszej wydajności oraz czytelności kodu;1
Czy String jest obiektem?;Nie, String jest primitive type podobnie jak int czy char wprowadzonym w Java dla uproszczenia operacji na tekstach;Tak, String jest obiektem klasy java.lang.String;String jest special type który zachowuje się jak primitive przy porównaniach == ale jest obiektem przy przypisaniach i przekazywaniu parametrów;String był obiektem do Java 8, potem został zmieniony na primitive type dla zwiększenia wydajności oraz redukcji zużycia pamięci;1
Co oznacza że String jest immutable?;String jest final więc nie może być dziedziczony przez inne klasy ale jego wartość może być modyfikowana przez własne metody;String może być modyfikowany tylko przez własne metody ale nie przez zewnętrzny kod co zapewnia enkapsulację danych;String nie może być zmieniony po utworzeniu. Każda operacja tworzy nowy String. Bezpieczne dla wątków;String cache'uje wszystkie wartości w String Pool więc modyfikacje są ignorowane dla wydajności i oszczędności pamięci;2
Jak skonwertować String na liczbę?;Integer.parseInt("123"), Integer.valueOf("123"), Long.parseLong(), Double.parseDouble(). Rzuca NumberFormatException;Używając rzutowania (int)"123" lub (Integer)"123" podobnie jak w przypadku konwersji między typami prostymi w Java;String.toInteger(), String.toLong(), String.toDouble() jako metody instance dostępne bezpośrednio na obiektach String;Integer.convert("123"), automatyczna konwersja przez autoboxing gdy przypisujesz String do zmiennej typu Integer w kodzie;0
Jaka jest różnica między rzutowaniem a parsowaniem?;Rzutowanie i parsowanie to synonimy w Java używane zamiennie w różnych kontekstach programistycznych dla zachowania kompatybilności;Parsowanie działa tylko dla konwersji String na inne typy, rzutowanie działa dla wszystkich typów reference i primitive;Rzutowanie to konwersja między typami (typ1) wartość. Parsowanie to konwersja String na inny typ (Integer.parseInt());Rzutowanie jest zawsze szybsze od parsowania, parsowanie jest bezpieczniejsze ale wolniejsze ze względu na dodatkową walidację;2
Jak konkatenować String-i w pętli aby było wydajne?;Używaj String += w każdej iteracji pętli, kompilator automatycznie optymalizuje to do StringBuilder w bytecode od Java 8;Użyj StringBuilder (nie synchronized) zamiast +. StringBuilder.append() i toString() na końcu;Używaj String.concat() w każdej iteracji która jest szybsza od operatora + przez bezpośrednie manipulowanie wewnętrzną tablicą char[];StringBuffer jest zawsze szybszy od StringBuilder w pętlach ze względu na lepszą optymalizację JVM dla synchronized operations;1
Czym jest StringBuilder i jakie ma wady/zalety?;StringBuilder to immutable klasa dla zapewnienia thread-safety podczas współbieżnego dostępu do tekstów w aplikacjach wielowątkowych;StringBuilder to mutable sekwencja znaków (od Java 5). Zalety: wydajny, nie synchronized. Wady: mutable (nie thread-safe);StringBuilder jest synchronized co zapewnia bezpieczeństwo wielowątkowe ale zmniejsza wydajność w porównaniu do StringBuffer;StringBuilder został całkowicie zastąpiony przez StringJoiner w Java 8 który oferuje lepszą wydajność oraz prostszą składnię;1
Czym jest StringBuffer i jakie ma wady/zalety?;StringBuffer to nowoczesna szybsza wersja StringBuilder wprowadzona w Java 8 z ulepszoną wydajnością operacji append oraz toString;StringBuffer to mutable sekwencja znaków (przed Java 5). Zalety: thread-safe (synchronized). Wady: wolniejszy niż StringBuilder;StringBuffer nie jest synchronized, to StringBuilder jest synchronized dla zapewnienia thread-safety w środowisku wielowątkowym;StringBuffer i StringBuilder są identyczne pod względem funkcjonalności, różnica jest tylko w nazwie dla kompatybilności z legacy code;1
Co to jest autoboxing i jaki jest tego cel?;Autoboxing to optymalizacja JVM dla typów prostych używanych w kolekcjach która cache'uje często używane wartości dla oszczędności pamięci;Autoboxing (Java 5+) to automatyczna konwersja między prostymi a wrapper klasami (int <-> Integer). Cel: wygoda, użycie w Collections;Autoboxing to mechanizm cache'owania wrapper objects w zakresie -128 do 127 dla Integer oraz podobnych zakresów dla innych typów;Autoboxing to przestarzały mechanizm który został zastąpiony przez var w Java 10 dla automatycznego type inference przez kompilator;1
Co to jest unboxing i po co jest potrzebne?;Unboxing to proces usuwania obiektów z Box containers które są specjalnym typem Collection wrapper dla przechowywania primitive values;Unboxing to automatyczna konwersja wrapper na typ prosty (Integer -> int). Potrzebne bo Collections zawierają tylko obiekty;Unboxing to deserializacja obiektów z formatu binarnego do formatu tekstowego podczas operacji I/O w aplikacjach Java;Unboxing to rozpakowywanie Optional values przez metody get() lub orElse() dla bezpiecznego dostępu do zawartości Optional;1
