Pytanie;Opcja0;Opcja1;Opcja2;Opcja3;indeks_poprawnej
Omów hierarchię wyjątków w Javie.;Exception jest root. Dzieli się na Throwable i Error;Throwable jest root. Dzieli się na Error i Exception. Exception dzieli się na checked i unchecked/RuntimeException;Error dziedziczy z Exception, RuntimeException dziedziczy z Error;Object -> Exception -> Throwable -> Error to prawidłowa hierarchia;1
Czym jest wyjątek?;Wyjątek to warning kompilator o potencjalnym problemie;Wyjątek to event który przerywa normalny przepływ programu. Reprezentuje sytuację błędu;Wyjątek to metoda która zawsze kończy się niepowodzeniem;Wyjątek to adnotacja oznaczająca ryzykowne operacje;1
Jak wyrzucić wyjątek?;raise ExceptionClass("message"); zgodnie z PEP 8;throw new ExceptionClass("message");;throws new ExceptionClass("message"); w deklaracji metody;Exception.throw("message"); przez statyczną metodę;1
Jak obsłużyć wyjątki?;try-catch blok. try { kod } catch (ExceptionType e) { obsługa };catch-try blok. catch (ExceptionType e) { obsługa } try { kod };except blok. except ExceptionType as e: obsługa;handle blok. handle(ExceptionType e) { obsługa };0
Co to Throwable?;Throwable to interfejs który Exception i Error implementują;Throwable to adnotacja oznaczająca że metoda może rzucić wyjątek;Throwable to superklasa dla Error i Exception. Zawiera stacktrace i message;Throwable to przestarzała nazwa dla Exception z Java 1.0;2
Jakie są różnice między Error a Exception?;Error może być obsłużony, Exception nie może być obsłużona;Nie ma różnic, Error to przestarzała nazwa dla Exception;Error: serio problemy (OutOfMemoryError, StackOverflowError) nie powinny być łapane. Exception: problemy które mogą być obsłużone;Error to checked exception, Exception to unchecked;2
Jakie są różnice między Exception a RuntimeException?;Exception to wszystkie checked i unchecked. RuntimeException to przestarzała nazwa;RuntimeException dziedziczy z Error nie z Exception;Exception (checked) musi być złapana lub w throws. RuntimeException (unchecked) nie musi być zadeklarowana;Exception jest szybsza, RuntimeException wolniejsza ale bezpieczniejsza;2
Czym są wyjątki checked oraz unchecked?;Checked to te sprawdzone przez testy, unchecked to niesprawdzone;Checked: Exception i podklasy (poza RuntimeException) muszą być obsłużone lub zadeklarowane. Unchecked: RuntimeException i podklasy;Checked to z JDK, unchecked to custom wyjątki użytkownika;Checked wymaga @Checked adnotacji, unchecked nie wymaga;1
Jakie wyjątki dodaje się do sygnatury metody?;Wszystkie wyjątki muszą być w sygnaturze;Checked exceptions. Przykład: void myMethod() throws IOException, SQLException { };Unchecked RuntimeExceptions muszą być deklarowane;Żadne, throws jest przestarzałe od Java 8;1
Jakie wyjątki są lepsze w praktyce checked czy unchecked?;Checked są zawsze lepsze bo wymuszają obsługę;Unchecked są zawsze lepsze bo dają elastyczność;Sporna kwestia. Checked wymusza obsługę ale może być uciążliwy. Unchecked daje elastyczność. Spring używa unchecked;Checked do Java 7, potem zawsze unchecked jako best practice;2
Czy można złapać Error?;Nie, kompilator nie pozwoli na catch(Error);Technicznie tak (catch(Error e)) ale to jest źle. Errory reprezentują serio problemy JVM i nie powinny być obsługiwane;Tak i jest to zalecane dla robustness aplikacji;Error są automatycznie łapane przez JVM;1
Czy można złapać i obsłużyć OutOfMemoryError?;Tak, to standardowa praktyka dla production apps;Technicznie tak ale prawie nigdy się nie uda. OutOfMemoryError oznacza że JVM zabrakło pamięci;OutOfMemoryError nie może być łapany zgodnie z JLS;OutOfMemoryError jest checked więc musi być obsługiwany;1
Jaką informację zawiera wyjątek?;Tylko message, reszta jest w logach;Message (opis błędu), stacktrace (seria metod), cause (underlying exception);Timestamp, thread ID, user information;Tylko typ wyjątku, message jest opcjonalne;1
Czym jest stacktrace i jak się do niego dostać?;Stacktrace to historia zmian obiektów na stosie;Stacktrace to lista metod. e.printStackTrace(), e.getStackTrace(), e.getMessage();Stacktrace to log wszystkich wyjątków od startu JVM;Stacktrace jest dostępny tylko przez debugger;1
Na czym polega przerzucenie wyjątku?;Przekazanie wyjątku do innego wątku;throw new CustomException("msg", cause); gdzie cause to inny wyjątek (exception chaining);Przeniesienie wyjątku z checked na unchecked;Konwersja Error na Exception;1
Czy wyjątki są wydajne? Czy można ich używać do kontroli przepływu?;Tak, wyjątki są zoptymalizowane przez JVM;Wyjątki są bardzo wydajne i można używać zamiast if-else;Wyjątki nie są wydajne (tworzą stacktrace). Nie używaj ich do kontroli przepływu zamiast if-else;Wyjątki wydajne tylko w Java 11+;2
Jaka jest różnica między throw a throws?;Nie ma różnicy, to synonimy;throw wyrzuca wyjątek. throws deklaruje że metoda może wyrzucić wyjątek;throw dla checked, throws dla unchecked;throw jest przestarzałe, używaj tylko throws;1
Czym jest blok try-catch-finally? Jaka jest kolejność wykonania?;try: kod. catch: obsługa. finally: zawsze się wykonuje (nawet po return). Kolejność: try, catch (jeśli wyjątek), finally;catch wykonuje się zawsze przed finally;finally wykonuje się tylko gdy nie ma wyjątku;try-catch-finally został zastąpiony przez try-with-resources;0
Kiedy kod z sekcji finally nie zostanie wykonany?;finally zawsze się wykonuje bez wyjątków;finally nie wykona się tylko przy compile error;Jeśli JVM zostanie wyłączona (System.exit()), infinite loop, fatal error, thread killed;finally nie wykona się gdy jest return w try;2
Czym jest try-with-resources?;try-with-resources to alias dla try-catch-finally;try-with-resources (Java 7+) automatycznie zamyka zasoby (AutoCloseable). Syntax: try (Resource r = new Resource()) { };try-with-resources to pattern dla zarządzania pamięcią;try-with-resources wymaga adnotacji @AutoClose;1
Na czym polega exceptions chaining?;Przekazywanie wyjątku przez kolejne metody bez obsługi;Wrapping jednego wyjątku w inny aby zachować kontekst. Przykład: throw new CustomException("error", originalException);;Łączenie wielu wyjątków w jeden MultiException;Automatyczne tworzenie hierarchii wyjątków przez JVM;1
Jaki jest cel rozszerzania RuntimeException oraz Exception?;Rozszerzanie jest deprecated, używaj gotowych wyjątków;Tylko framework developerzy powinni rozszerzać te klasy;Tworzenie custom wyjątków dla domeny aplikacji. RuntimeException dla unchecked, Exception dla checked;Wszystkie custom wyjątki muszą dziedziczyć z Error;2
Wymień kilka wyjątków wbudowanych w Javie.;NullPointerException, ArrayIndexOutOfBoundsException, ClassCastException, IllegalArgumentException, IOException;FileException, DataException, SystemException, NetworkException;CompileException, RuntimeError, SystemError, MemoryException;InvalidException, ErrorException, FailureException;0
Jakie są reguły nadpisywania metody która wyrzuca wyjątek?;Metoda w podklasie może wyrzucić dowolne wyjątki;Metoda w podklasie nie może wyrzucać żadnych wyjątków;Metoda w podklasie może wyrzucić takie same lub węższe (bardziej konkretne) wyjątki. Nie może szerszych;Nadpisywanie metod z wyjątkami jest niedozwolone;2
