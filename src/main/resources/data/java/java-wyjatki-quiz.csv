Pytanie;Opcja0;Opcja1;Opcja2;Opcja3;indeks_poprawnej
Omów hierarchię wyjątków w Javie.;Exception jest root class hierarchii. Dzieli się bezpośrednio na Throwable i Error jako główne gałęzie wyjątków;Throwable jest root. Dzieli się na Error i Exception. Exception dzieli się na checked i unchecked/RuntimeException;Error dziedziczy z Exception jako podklasa, RuntimeException dziedziczy z Error tworząc trzystopniową hierarchię;Object -> Exception -> Throwable -> Error to prawidłowa kolejność dziedziczenia zgodnie z dokumentacją Oracle;1
Czym jest wyjątek?;Wyjątek to warning od kompilatora o potencjalnym problemie w kodzie który może ale nie musi wystąpić podczas wykonania;Wyjątek to event który przerywa normalny przepływ programu. Reprezentuje sytuację błędu;Wyjątek to metoda która zawsze kończy się niepowodzeniem i rzuca błąd dla sygnalizowania problemów w logice biznesowej;Wyjątek to adnotacja używana do oznaczania ryzykownych operacji które mogą zawieść podczas wykonywania kodu;1
Jak wyrzucić wyjątek?;raise ExceptionClass("message"); zgodnie z konwencją PEP 8 oraz składnią Python-like wprowadzoną w Java 11;throw new ExceptionClass("message");;throws new ExceptionClass("message"); w deklaracji sygnatury metody jako część kontraktu interfejsu;Exception.throw("message"); przez wywołanie statycznej metody throw z klasy Exception z pakietu java.lang;1
Jak obsłużyć wyjątki?;try-catch blok. try { kod } catch (ExceptionType e) { obsługa };catch-try blok. catch (ExceptionType e) { obsługa } try { kod }; gdzie catch musi być przed try dla poprawnej składni;except blok. except ExceptionType as e: obsługa zgodnie z składnią Python-like wprowadzoną w nowszych wersjach;handle blok. handle(ExceptionType e) { obsługa } jako nowa konstrukcja językowa dodana w Java 11;0
Co to Throwable?;Throwable to interfejs który klasy Exception i Error implementują dla zapewnienia wspólnego kontraktu obsługi błędów;Throwable to adnotacja @Throwable oznaczająca że metoda może rzucić wyjątek i wymaga deklaracji throws w sygnaturze;Throwable to superklasa dla Error i Exception. Zawiera stacktrace i message;Throwable to przestarzała deprecated nazwa dla Exception z Java 1.0 zachowana dla backward compatibility;2
Jakie są różnice między Error a Exception?;Error może być obsłużony przez try-catch i powinien być, Exception nie może być obsłużona tylko zadeklarowana;Nie ma żadnych różnic, Error to tylko przestarzała deprecated nazwa dla Exception używana w starym kodzie Java 1.0;Error: serio problemy (OutOfMemoryError, StackOverflowError) nie powinny być łapane. Exception: problemy które mogą być obsłużone;Error to checked exception wymagający deklaracji, Exception to unchecked który nie wymaga throws w sygnaturze;2
Jakie są różnice między Exception a RuntimeException?;Exception to wszystkie checked i unchecked exceptions łącznie. RuntimeException to przestarzała deprecated nazwa z Java 1.0;RuntimeException dziedziczy bezpośrednio z Error nie z Exception tworząc osobną gałąź hierarchii wyjątków;Exception (checked) musi być złapana lub w throws. RuntimeException (unchecked) nie musi być zadeklarowana;Exception jest szybsza w wykonaniu, RuntimeException wolniejsza ale bezpieczniejsza przez dodatkowe sprawdzenia kompilator;2
Czym są wyjątki checked oraz unchecked?;Checked to te sprawdzone przez automated tests, unchecked to niesprawdzone wymagające ręcznej weryfikacji przed deploymentem;Checked: Exception i podklasy (poza RuntimeException) muszą być obsłużone lub zadeklarowane. Unchecked: RuntimeException i podklasy;Checked to wyjątki z JDK standard library, unchecked to custom wyjątki stworzone przez użytkownika aplikacji;Checked wymaga adnotacji @Checked przed klasą wyjątku, unchecked nie wymaga żadnych dodatkowych adnotacji;1
Jakie wyjątki dodaje się do sygnatury metody?;Wszystkie wyjątki zarówno checked jak unchecked muszą być zawsze deklarowane w sygnaturze metody dla kompletności;Checked exceptions. Przykład: void myMethod() throws IOException, SQLException { };Unchecked RuntimeExceptions muszą być obowiązkowo deklarowane w throws, checked są opcjonalne dla elastyczności;Żadne wyjątki nie są dodawane, słowo kluczowe throws jest deprecated od Java 8 i nie powinno być używane;1
Jakie wyjątki są lepsze w praktyce checked czy unchecked?;Checked są zawsze lepsze we wszystkich przypadkach bo wymuszają obsługę błędów i zwiększają niezawodność aplikacji;Unchecked są zawsze lepsze w każdym scenariuszu bo dają maksymalną elastyczność i nie zaśmiecają kodu try-catch;Sporna kwestia. Checked wymusza obsługę ale może być uciążliwy. Unchecked daje elastyczność. Spring używa unchecked;Checked do Java 7 jako standard, potem zawsze unchecked jako best practice zgodnie z zaleceniami Oracle;2
Czy można złapać Error?;Nie, kompilator nie pozwoli na konstrukcję catch(Error) i kod nie skompiluje się z błędem składni;Technicznie tak (catch(Error e)) ale to jest źle. Errory reprezentują serio problemy JVM i nie powinny być obsługiwane;Tak i jest to zalecane jako best practice dla robustness aplikacji production-ready zwiększając niezawodność;Error są automatycznie łapane przez JVM runtime environment i nie mogą być przechwytywane przez kod użytkownika;1
Czy można złapać i obsłużyć OutOfMemoryError?;Tak, to standardowa praktyka dla production apps zwiększająca stabilność i niezawodność systemów enterprise;Technicznie tak ale prawie nigdy się nie uda. OutOfMemoryError oznacza że JVM zabrakło pamięci;OutOfMemoryError nie może być łapany przez konstrukcję try-catch zgodnie z Java Language Specification JLS;OutOfMemoryError jest checked exception więc musi być obsługiwany lub zadeklarowany w throws zgodnie z kontraktem;1
Jaką informację zawiera wyjątek?;Tylko message jako opis błędu, reszta informacji jest automatycznie zapisywana w plikach logów przez JVM;Message (opis błędu), stacktrace (seria metod), cause (underlying exception);Timestamp utworzenia, thread ID wykonania, user information oraz system properties w momencie wystąpienia błędu;Tylko typ wyjątku jako nazwa klasy, message jest opcjonalne i może być null w wielu przypadkach;1
Czym jest stacktrace i jak się do niego dostać?;Stacktrace to historia wszystkich zmian wartości obiektów na stosie pamięci podczas wykonywania programu;Stacktrace to lista metod wywołanych przed wyjątkiem. e.printStackTrace(), e.getStackTrace(), e.getMessage();Stacktrace to log zawierający wszystkie wyjątki od startu JVM zapisywany automatycznie do pliku trace.log;Stacktrace jest dostępny tylko przez debugger IDE i nie może być programowo dostępny w kodzie aplikacji;1
Na czym polega przerzucenie wyjątku?;Przekazanie wyjątku do innego wątku w aplikacji wielowątkowej dla przetworzenia w kontekście background thread;throw new CustomException("msg", cause); gdzie cause to inny wyjątek (exception chaining);Przeniesienie wyjątku z kategorii checked na unchecked przez wrappowanie w RuntimeException automatycznie przez JVM;Konwersja Error na Exception dla możliwości obsługi przez try-catch który nie może łapać Error types;1
Czy wyjątki są wydajne? Czy można ich używać do kontroli przepływu?;Tak, wyjątki są zoptymalizowane przez JVM i można używać zamiast if-else dla lepszej wydajności;Wyjątki są bardzo wydajne przez cache stacktrace mechanism i mogą być używane do flow control jako best practice;Wyjątki nie są wydajne (tworzą stacktrace). Nie używaj ich do kontroli przepływu zamiast if-else;Wyjątki są wydajne tylko w Java 11+ przez wprowadzenie lightweight exceptions bez stacktrace overhead;2
Jaka jest różnica między throw a throws?;Nie ma żadnej różnicy, to są synonimy używane zamiennie w różnych kontekstach składniowych języka Java;throw wyrzuca wyjątek. throws deklaruje że metoda może wyrzucić wyjątek;throw jest używany dla checked exceptions, throws dla unchecked RuntimeException zgodnie z konwencją;throw jest deprecated od Java 8, należy używać tylko throws w deklaracji metod dla spójności;1
Czym jest blok try-catch-finally? Jaka jest kolejność wykonania?;try: kod. catch: obsługa. finally: zawsze się wykonuje (nawet po return). Kolejność: try, catch (jeśli wyjątek), finally;catch wykonuje się zawsze przed finally niezależnie od tego czy wystąpił wyjątek czy nie dla spójności;finally wykonuje się tylko gdy nie ma żadnego wyjątku w try block jako cleanup po udanym wykonaniu;try-catch-finally został całkowicie zastąpiony przez try-with-resources w Java 7 i nie powinien być używany;0
Kiedy kod z sekcji finally nie zostanie wykonany?;finally zawsze się wykonuje bez żadnych wyjątków w 100% przypadków zgodnie z gwarancją Java Language Specification;finally nie wykona się tylko gdy wystąpi compile error lub syntax error w kodzie try lub catch block;Jeśli JVM zostanie wyłączona (System.exit()), infinite loop, fatal error, thread killed;finally nie wykona się gdy jest instrukcja return w bloku try lub catch zwracająca wartość z metody;2
Czym jest try-with-resources?;try-with-resources to alias dla try-catch-finally wprowadzony w Java 8 dla czytelności bez zmian funkcjonalności;try-with-resources (Java 7+) automatycznie zamyka zasoby (AutoCloseable). Syntax: try (Resource r = new Resource()) { };try-with-resources to design pattern dla zarządzania pamięcią heap memory i alokacji obiektów large objects;try-with-resources wymaga adnotacji @AutoClose na klasie zasobu oraz implementacji metody dispose() zamiast close();1
Na czym polega exceptions chaining?;Przekazywanie wyjątku przez kolejne metody w call stack bez obsługi aż do main method lub thread handler;Wrapping jednego wyjątku w inny aby zachować kontekst. Przykład: throw new CustomException("error", originalException);;Łączenie wielu wyjątków w jeden MultiException container dla zbiorczej obsługi wszystkich błędów naraz;Automatyczne tworzenie hierarchii dziedziczenia wyjątków przez JVM runtime podczas propagacji exception w górę stosu;1
Jaki jest cel rozszerzania RuntimeException oraz Exception?;Rozszerzanie jest deprecated, należy zawsze używać gotowych wyjątków z JDK bez tworzenia custom exception classes;Tylko framework developerzy powinni rozszerzać te klasy, application code nie powinien tworzyć custom exceptions;Tworzenie custom wyjątków dla domeny aplikacji. RuntimeException dla unchecked, Exception dla checked;Wszystkie custom wyjątki muszą obowiązkowo dziedziczyć z Error nie z Exception dla poprawnej kategoryzacji;2
Wymień kilka wyjątków wbudowanych w Javie.;NullPointerException, ArrayIndexOutOfBoundsException, ClassCastException, IllegalArgumentException, IOException;FileException, DataException, SystemException, NetworkException jako główne kategorie wyjątków systemowych;CompileException, RuntimeError, SystemError, MemoryException z pakietu java.lang.error dla błędów krytycznych;InvalidException, ErrorException, FailureException z java.util.exceptions dla operacji na kolekcjach;0
Jakie są reguły nadpisywania metody która wyrzuca wyjątek?;Metoda w podklasie może wyrzucić dowolne wyjątki checked i unchecked bez żadnych ograniczeń hierarchii;Metoda w podklasie nie może wyrzucać żadnych wyjątków jeśli metoda nadrzędna deklaruje throws w sygnaturze;Metoda w podklasie może wyrzucić takie same lub węższe (bardziej konkretne) wyjątki. Nie może szerszych;Nadpisywanie metod z wyjątkami jest całkowicie niedozwolone zgodnie z zasadą Liskov Substitution Principle;2
