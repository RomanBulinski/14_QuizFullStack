Pytanie;Opcja0;Opcja1;Opcja2;Opcja3;indeks_poprawnej
Czym jest JCF w Javie?;JCF to Java Class Framework będący rozbudowanym systemem do zarządzania hierarchią dziedziczenia klas oraz interfejsów w aplikacjach obiektowych;Java Collections Framework: standardowa biblioteka do pracy z grupami obiektów. Zawiera interfejsy (Collection, Set, List, Map) i implementacje;JCF to Java Compilation Framework odpowiedzialny za optymalizację bytecode podczas kompilacji oraz dynamiczne ładowanie klas przez ClassLoader;JCF to przestarzała biblioteka która została całkowicie zastąpiona przez java.util.stream i nowoczesny Stream API wprowadzony w Java 8;1
Jaka jest hierarchia kolekcji w Javie?;Map -> Collection -> {List, Set, Queue} gdzie wszystkie kolekcje dziedziczą z Map jako głównego interfejsu kolekcyjnego;Collection -> Iterable -> {List, Set, Queue, Map} gdzie wszystkie struktury danych dziedziczą z Collection jako bazowego interfejsu;Iterable -> Collection -> {List, Set, Queue}. Map nie dziedziczy z Collection ale jest częścią JCF;Object -> Collection -> wszystkie kolekcje bezpośrednio dziedziczą z Collection jako podklasy Object w hierarchii Javy;2
Czym jest Iterable<E>?;Iterable to przestarzały interfejs który został zastąpiony przez Stream API w Java 8 ze względu na lepszą wydajność przetwarzania sekwencyjnego;Iterable to interfejs który pozwala na iterację. Dostarcza iterator(). Pozwala na for-each pętlę;Iterable to klasa abstrakcyjna dla wszystkich kolekcji która definiuje podstawowe metody add, remove oraz contains dla wszystkich typów kolekcji;Iterable to adnotacja dla klas które mogą być iterowane w pętlach for-each oraz definiuje zachowanie podczas serializacji obiektów;1
Czym jest Iterator<E>?;Iterator to klasa do tworzenia nieskończonych sekwencji elementów podobnie jak Stream.generate() oraz zarządzania stanem iteracji w pamięci;Iterator to interfejs do przechodzenia przez elementy. Metody: hasNext(), next(), remove();Iterator to deprecated mechanizm z Java 1.0 który został zastąpiony przez ListIterator oraz Spliterator w nowszych wersjach języka;Iterator to functional interface dla lambda expressions który pozwala na definiowanie własnych strategii iteracji w streamach;1
Jaka jest różnica między Iterable<E> a Iterator<E>?;Nie ma żadnej różnicy między nimi, to są tylko synonimy używane zamiennie w różnych kontekstach programistycznych dla zachowania kompatybilności;Iterator jest znacznie szybszy niż Iterable dzięki wewnętrznej optymalizacji JVM oraz lepszemu zarządzaniu pamięcią podczas iteracji;Iterable dostarcza iterator(). Iterator jest narzędziem do iteracji;Iterable jest używane dla thread-safe kolekcji synchronizowanych, natomiast Iterator jest przeznaczony tylko dla normalnych kolekcji niebezpiecznych wielowątkowo;2
Jakie listy dostępne są w Javie?;ArrayList, LinkedList, Vector, Stack, CopyOnWriteArrayList;List, Array, LinkedArray, VectorList, StackList jako główne implementacje interfejsu ListStructure wprowadzonego w Java Collections Framework;Tylko ArrayList i LinkedList, ponieważ reszta implementacji została oznaczona jako deprecated w Java 8 i usunięta w Java 11;List<T> to jedyna uniwersalna implementacja od Java 8 która dynamicznie wybiera wewnętrzną strukturę danych na podstawie rozmiaru kolekcji;0
Z jakiej struktury danych korzysta ArrayList?;Linked list z pointerami łączącymi elementy oraz dodatkowymi referencjami previous i next dla szybszego dostępu dwukierunkowego;Dynamiczna tablica. Capacity podwaja się gdy jest pełna;Hash table z bucketami dla każdego elementu oraz mechanizmem rozwiązywania kolizji przez osobne łańcuchy linkedlist w każdym buckecie;Binary tree dla szybkiego dostępu z O(log n) czasem wyszukiwania oraz automatycznym balansowaniem przez algorytm Red-Black;1
Z jakiej struktury danych korzysta LinkedList?;Dynamiczna tablica z automatycznym resize zwiększającym capacity o 50% przy każdym przepełnieniu dla optymalnego wykorzystania pamięci;Hash table z linked nodes łącząca węzły w bucketach oraz używająca hashCode() do dystrybucji elementów po strukturze;Doubly linked list. Każdy node ma referencje do next i previous;Single linked list tylko z next pointer dla oszczędności pamięci oraz szybszej alokacji węzłów w heap memory;2
Czym jest Stack<E>? Jakie ma wady?;Stack to najszybsza struktura LIFO w Java zoptymalizowana przez JVM z O(1) czasem dla wszystkich operacji oraz wbudowaną synchronizacją wątków;Stack to LIFO struktura. extends Vector (deprecated). Lepiej użyć Deque (ArrayDeque);Stack to FIFO kolejka specjalnie zaprojektowana dla wielowątkowości z automatycznym lock-free mechanizmem dostępu współbieżnego;Stack nie ma żadnych wad, to najlepsza implementacja struktury stosowej zalecana przez Oracle w dokumentacji Java Collections Framework;1
Czym jest Vector<E>? Jakie ma wady?;Vector to nowoczesna implementacja ArrayList wprowadzona w Java 8 z ulepszoną wydajnością oraz zredukowanym zużyciem pamięci;Vector to legacy synchronized ArrayList. Wady: synchronized (powolny), deprecated. Użyj ArrayList z synchronizedList() lub CopyOnWriteArrayList;Vector to thread-safe wersja LinkedList która używa synchronized methods oraz ReentrantLock dla zapewnienia bezpieczeństwa wielowątkowego;Vector to przestarzała nazwa dla ArrayList która została zmieniona w Java 5 dla lepszej spójności nazewnictwa w Collections Framework;1
Jaka jest idea kolejek w Javie?;Queue to LIFO (Last In First Out) struktura służąca do implementacji stosu oraz zarządzania elementami w odwrotnej kolejności dodawania;Queue to struktura do automatycznego sortowania elementów według ich natural ordering lub podanego Comparator z zachowaniem kolejności priorytetów;Queue to FIFO (First In First Out) struktura. add/offer (insert), remove/poll (delete), element/peek (view);Queue to deprecated interfejs z Java 1.0 który został zastąpiony przez Deque oraz PriorityQueue w nowszych wersjach języka;2
Jaka jest różnica między Queue<E> oraz Dequeue<E>?;Nie ma żadnej różnicy między nimi, Dequeue to tylko typo powstałe podczas refactoringu w Java 6 i zachowane dla backward compatibility;Queue: FIFO. Deque (Double Ended Queue): może działać jako FIFO lub LIFO. Operacje na obu końcach;Queue jest thread-safe z synchronized methods, natomiast Deque nie jest thread-safe i wymaga zewnętrznej synchronizacji podczas użycia współbieżnego;Dequeue to przestarzała nazwa dla PriorityQueue która była używana w Java 1.4 przed wprowadzeniem generics i została zmieniona na PriorityQueue;1
Czym jest PriorityQueue<E>?;PriorityQueue to FIFO kolejka z priorytetami reprezentowanymi jako liczby całkowite od 0 do Integer.MAX_VALUE przypisywane każdemu elementowi podczas dodawania;PriorityQueue to kolejka gdzie elementy uporządkowane po priorytecie (Comparable lub Comparator). Min-heap domyślnie;PriorityQueue to thread-safe wersja Queue z wbudowaną synchronizacją oraz lock-free algorytmami dla wysokiej wydajności w środowisku wielowątkowym;PriorityQueue automatycznie sortuje wszystkie elementy alfabetycznie przy użyciu metody toString() oraz ignoruje Comparable i Comparator interfaces;1
Z jakich algorytmów korzysta kolejka priorytetowa?;Linked list z sortowaniem przez insertion sort przy każdym dodaniu elementu dla zachowania stałej kolejności priorytetów;Hash table z bucketing gdzie bucket number odpowiada priorytetowi elementu oraz collision resolution przez separate chaining;Binary heap. Insert O(log n), deleteMin O(log n), peek O(1);Red-Black tree dla automatycznego balance oraz gwarancji O(log n) dla wszystkich operacji z możliwością dwukierunkowej iteracji w sorted order;2
Czym jest Set<E>? Jakie ma implementacje?;Set to kolekcja z duplikatami posortowana alfabetycznie lub numerycznie według natural ordering elementów przechowywanych w strukturze;Set to przestarzały interfejs z Java 1.0 który został zastąpiony przez List<E> z unique constraint w Java 8 Collections Framework;Set to kolekcja bez duplikatów. HashSet, LinkedHashSet, TreeSet, EnumSet, CopyOnWriteArraySet;Set to tylko HashSet, a reszta to legacy klasy które zostały deprecated i usunięte w Java 11 dla uproszczenia API;2
Jak zaimplementowany został HashSet<E>?;HashSet używa array list wewnętrznie do przechowywania elementów z dodatkową hash tablicą dla szybkiego sprawdzania duplikatów;HashSet używa HashMap wewnętrznie. Elementy są kluczami, wartości to dummy object. O(1) average case;HashSet używa TreeMap z Red-Black tree dla automatycznego sortowania elementów oraz utrzymywania ich w natural order podczas iteracji;HashSet to proste wrapper na ArrayList który sprawdza duplikaty przez iterację i porównanie wszystkich elementów za pomocą equals();1
Jak zaimplementowany został TreeSet<E>?;TreeSet używa hash table z dodatkowym sortowaniem przez Comparator który jest wywoływany po każdej operacji add lub remove;TreeSet używa ArrayList posortowanego przez Arrays.sort() lub Collections.sort() z binary search dla operacji contains oraz remove;TreeSet używa TreeMap (Red-Black tree) wewnętrznie. Elementy są kluczami. O(log n) operacje, sorted;TreeSet to wrapper na PriorityQueue który używa heap structure oraz automatycznie sortuje elementy według priorytetu jako klucza;2
Czy mapa jest kolekcją?;Tak, Map extends Collection jako główny interfejs i wszystkie mapy są kolekcjami w Java Collections Framework;Nie technicznie, ale jest częścią JCF. Map nie implementuje Collection, ma własny interfejs;Tak, ale tylko HashMap jest kolekcją implementującą Collection, pozostałe implementacje Map nie są kolekcjami;Map stała się kolekcją dopiero od Java 8 gdy dodano default methods pozwalające na implementację interfejsu Collection;1
Jak działa HashMap<K,V>?;HashMap używa ArrayList z parami key-value przechowywanymi jako Entry objects oraz linear search dla operacji get i put;HashMap używa hash table. Klucze hashovane do bucket. Przy kolizjach: Java 8+ używa linked list, potem tree. O(1) average;HashMap używa binary tree dla wszystkich kluczy gdzie każdy node zawiera key-value pair oraz lewy i prawy child pointer;HashMap to wrapper na Hashtable który dodaje null keys i values oraz usuwa synchronizację dla lepszej wydajności;1
Jak działa TreeMap<K,V>?;TreeMap używa hash table z automatycznym sortowaniem kluczy przez dodatkową strukturę sorted array przechowującą posortowane indeksy;TreeMap używa ArrayList posortowanego przez natural ordering kluczy z binary search dla operacji get oraz put;TreeMap to Red-Black tree. Klucze posortowane. O(log n) operacje;TreeMap używa heap structure podobnie jak PriorityQueue gdzie root zawiera najmniejszy klucz według Comparator lub Comparable;2
Jakie cechy powinien mieć dobry klucz w mapie?;Mutable i często zmieniany dla flexibility pozwalającej na aktualizację wartości hashCode oraz dynamiczne reorganizowanie struktury HashMap;Tylko String może być kluczem w HashMap ponieważ inne typy nie implementują wymaganej metody hashKey() potrzebnej przez hash table;Immutable, prawidłowa implementacja equals() i hashCode(), hashCode() spójny z equals();Klucze muszą implementować Comparable zawsze ponieważ HashMap używa porównywania natural ordering do rozwiązywania kolizji;2
Czym jest load factor?;Load factor to całkowita liczba elementów przechowywanych obecnie w HashMap oraz określa aktualny rozmiar struktury;Load factor to ratio size/capacity. Decyduje kiedy rehashować. Default 0.75 (balans między czasem a pamięcią);Load factor to maksymalny rozmiar HashMap określony podczas konstrukcji który nie może być przekroczony bez throwing Exception;Load factor to deprecated parametr z Java 7 który został usunięty w Java 8 na rzecz automatycznego dynamic resizing;1
Jak posortować wybrane kolekcje?;list.sort() to jedyna metoda wprowadzona w Java 8 jako default method w interfejsie List dostępna dla wszystkich implementacji;Collections.sort(list), Collections.sort(list, comparator), Arrays.sort(array);Kolekcje sortują się automatycznie podczas dodawania elementów gdy implementują Sortable interface wprowadzony w Java 7;Tylko TreeSet i TreeMap mogą być sortowane ponieważ inne kolekcje nie wspierają Comparable ani Comparator interfaces;1
Jakie algorytmy sortowania używane są w JCF?;Tylko Bubble sort dla wszystkich kolekcji ze względu na prostotę implementacji oraz łatwość debugowania w środowisku produkcyjnym;Quicksort (Arrays.sort dla arrays), Mergesort (Collections.sort), Timsort (Java 8+);Insertion sort dla wszystkich kolekcji mniejszych niż 100 elementów oraz Quicksort dla większych ze względu na optymalizację wydajności;Heap sort jako jedyny algorytm od Java 8 który zastąpił wszystkie poprzednie algorytmy dla spójności implementacji;1
Czym jest Collections?;Collections to interfejs bazowy dla wszystkich kolekcji który definiuje podstawowe metody jak add, remove, contains oraz iterator;Collections to utility class z static metodami: sort(), shuffle(), reverse(), max(), min(), copy(), fill();Collections to przestarzała klasa z Java 1.0 która została zastąpiona przez Streams API w Java 8 dla lepszej funkcjonalności;Collections to synonim dla Collection używany zamiennie w dokumentacji Oracle oraz starszym kodzie przed Java 5;1
