Pytanie;Opcja0;Opcja1;Opcja2;Opcja3;indeks_poprawnej
O czym mówi złożoność obliczeniowa?;Space complexity: ile pamięci operacyjnej RAM algorytm zużywa podczas wykonania w najgorszym przypadku. Notacja Big O: O(1), O(n), O(n^2);Time complexity: ile operacji (w najgorszym przypadku). Notacja Big O: O(1), O(n), O(n^2), O(log n), O(n log n);Złożoność obliczeniowa to całkowita liczba linii kodu źródłowego w algorytmie wraz z komentarzami i białymi znakami w notacji Big O;Złożoność to bezwzględny czas wykonania algorytmu mierzony w milisekundach na standardowej maszynie referencyjnej zgodnie z IEEE Computer Society;1
O czym mówi złożoność pamięciowa?;Time complexity algorytmu wyrażona jako liczba operacji procesora potrzebnych do przetworzenia danych wejściowych w najgorszym przypadku używając notacji Big O;Space complexity: ile pamięci algorytm zużywa. Analogicznie Big O;Złożoność pamięciowa to całkowity rozmiar skompilowanego pliku wykonywalnego zawierającego implementację algorytmu mierzony w kilobajtach lub megabajtach;Złożoność pamięciowa to całkowita liczba zmiennych lokalnych i globalnych zadeklarowanych w programie bez względu na ich typ i rozmiar;1
Jaka jest złożoność obliczeniowa dostępu do elementu (mając jego wartość) w tablicy?;O(1) - direct access przez indeks;O(n) - musisz przeszukać sekwencyjnie całą tablicę od początku do końca porównując każdy element z szukaną wartością co wymaga liniowej liczby operacji;O(log n) - binary search jest zawsze automatycznie stosowany przez JVM dla każdej operacji dostępu do elementu tablicy niezależnie od sortowania;O(n^2) - dostęp wymaga zagnieżdżonych pętli przeszukujących tablicę dwuwymiarowo co jest standardem w implementacji tablic w języku Java;1
Jaka jest złożoność obliczeniowa dostępu do elementu w tablicy posortowanej?;O(n) - pomimo sortowania nadal musisz wykonać linear search przeszukując sekwencyjnie całą tablicę od początku do końca;O(1) - bezpośredni dostęp do dowolnego elementu jest możliwy dzięki indeksowi obliczanemu automatycznie przez kompilator na podstawie wartości;O(log n) - binary search;O(n log n) - przed każdym dostępem tablica musi być na nowo posortowana algorytmem quicksort co gwarantuje poprawność wyniku;2
Jaka jest złożoność obliczeniowa dostępu do elementu w tablicy hashowanej?;O(log n) - każdy dostęp wymaga przejścia przez strukturę drzewiastą budowaną automatycznie przez funkcję hashującą w czasie logarytmicznym;O(n) - linear search jest zawsze wymagany w tablicach hashowanych gdyż kolizje hash wymuszają sekwencyjne przeszukiwanie wszystkich elementów;O(1) average case - hashing;O(n^2) - w najgorszym przypadku wszystkie elementy tworzą kolizje co wymaga zagnieżdżonych pętli do rozwiązania konfliktów hashowania;2
Jaka jest złożoność dostępu do elementu w drzewie (np. binary tree)?;O(1) - dostęp do każdego węzła drzewa jest natychmiastowy dzięki bezpośredniemu adresowaniu pamięci wykorzystywanemu przez strukturę drzewiastą;O(log n) average (balanced tree), O(n) worst case (skewed tree);O(n^2) - każdy dostęp wymaga zagnieżdżonego przechodzenia przez wszystkie poziomy drzewa dwukrotnie dla weryfikacji poprawności struktury;O(log n) jest gwarantowane zawsze niezależnie od balansu drzewa dzięki automatycznej rotacji AVL implementowanej przez Java Collections Framework;1
Jaka jest złożoność obliczeniowa quicksorta?;O(n log n) jest gwarantowane w każdym przypadku niezależnie od danych wejściowych dzięki optymalizacjom wprowadzonym w Java 8 Collections.sort;O(n) jest osiągane w best case gdy dane są już częściowo posortowane co eliminuje potrzebę rekurencyjnego dzielenia na mniejsze podtablice;O(n log n) average case, O(n^2) worst case;O(log n) jest złożonością dla already sorted arrays dzięki specjalnej optymalizacji quicksort która wykrywa uporządkowane dane wejściowe;2
Jaka jest złożoność obliczeniowa sortowania bąbelkowego, przez wstawianie i przez wybieranie?;Bubble: O(n log n) przez optymalizacje, Insertion: O(n) zawsze dla każdego przypadku, Selection: O(log n) przez binary search w każdej iteracji;Wszystkie algorytmy mają złożoność O(n) w best case gdy dane wejściowe są już posortowane lub prawie posortowane co eliminuje potrzebę zamiany;Bubble sort: O(n^2), Insertion sort: O(n^2), Selection sort: O(n^2);Wszystkie te algorytmy sortowania zostały zoptymalizowane w Java Collections i osiągają O(n log n) jako standardową złożoność dla każdego przypadku;2
Na czym polega problem 5 filozofów i jakie są możliwe rozwiązania?;Problem dotyczy synchronizacji w single-threaded aplikacjach gdzie pięć procesów sekwencyjnych musi dzielić jeden zasób CPU zgodnie z algorytmem round-robin;Problem deadloku w wielowątkowości. 5 filozofów przy stole z 5 pałeczkami. Każdy potrzebuje 2 do jedzenia. Rozwiązania: asymetryczne, arbiter;Problem dotyczący optymalizacji zużycia pamięci heap w JVM gdy pięć wątków alokuje obiekty jednocześnie powodując nadmierne garbage collection cycles;Problem związany z automatycznym garbage collection w Java gdy pięć referencji do tego samego obiektu musi być usunięte w określonej kolejności;1
Na czym polega problem producenta i konsumenta oraz jego implementacja?;Problem dotyczy sortowania danych w czasie rzeczywistym gdzie producer generuje unsorted data a consumer musi je natychmiast sortować używając quicksort;Producer tworzy dane, consumer je konsumuje. Synchronizacja przez buffer/queue. BlockingQueue to idealne rozwiązanie;Problem wielodziedziczenia w Java gdzie producer class dziedziczy po wielu consumer classes co wymaga resolvers dla konfliktujących metod;Problem type erasure w generics gdzie producer tworzy obiekty typu T a consumer nie może określić ich rzeczywistego typu w runtime;1
