Pytanie;Opcja0;Opcja1;Opcja2;Opcja3;indeks_poprawnej
O czym mówi złożoność obliczeniowa?;Space complexity: ile pamięci algorytm zużywa;Time complexity: ile operacji (w najgorszym przypadku). Notacja Big O: O(1), O(n), O(n^2), O(log n), O(n log n);Złożoność to liczba linii kodu w algorytmie;Złożoność to czas wykonania w milisekundach;1
O czym mówi złożoność pamięciowa?;Time complexity algorytmu;Space complexity: ile pamięci algorytm zużywa. Analogicznie Big O;Rozmiar pliku wykonywalnego;Liczba zmiennych w programie;1
Jaka jest złożoność obliczeniowa dostępu do elementu (mając jego wartość) w tablicy?;O(1) - direct access przez indeks;O(n) - musisz przeszukać całą tablicę;O(log n) - binary search zawsze;O(n^2) - nested loops;1
Jaka jest złożoność obliczeniowa dostępu do elementu w tablicy posortowanej?;O(n) - linear search;O(1) - direct access;O(log n) - binary search;O(n log n) - quicksort first;2
Jaka jest złożoność obliczeniowa dostępu do elementu w tablicy hashowanej?;O(log n) - tree structure;O(n) - linear search zawsze;O(1) average case - hashing;O(n^2) worst case zawsze;2
Jaka jest złożoność dostępu do elementu w drzewie (np. binary tree)?;O(1) - zawsze stały czas;O(log n) average (balanced tree), O(n) worst case (skewed tree);O(n^2) - nested traversal;O(log n) zawsze, nawet dla unbalanced;1
Jaka jest złożoność obliczeniowa quicksorta?;O(n log n) zawsze;O(n) best case zawsze;O(n log n) average case, O(n^2) worst case;O(log n) dla sorted arrays;2
Jaka jest złożoność obliczeniowa sortowania bąbelkowego, przez wstawianie i przez wybieranie?;Bubble: O(n log n), Insertion: O(n), Selection: O(log n);Wszystkie O(n) dla best case;Bubble sort: O(n^2), Insertion sort: O(n^2), Selection sort: O(n^2);Wszystkie O(n log n) jako standard;2
Na czym polega problem 5 filozofów i jakie są możliwe rozwiązania?;Problem synchronizacji w single-threaded aplikacjach;Problem deadloku w wielowątkowości. 5 filozofów przy stole z 5 pałeczkami. Każdy potrzebuje 2 do jedzenia. Rozwiązania: asymetryczne, arbiter;Problem optymalizacji pamięci w JVM;Problem garbage collection w Java;1
Na czym polega problem producenta i konsumenta oraz jego implementacja?;Problem sortowania danych w czasie rzeczywistym;Producer tworzy dane, consumer je konsumuje. Synchronizacja przez buffer/queue. BlockingQueue to idealne rozwiązanie;Problem wielodziedziczenia w Java;Problem type erasure w generics;1
