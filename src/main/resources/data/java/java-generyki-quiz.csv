Pytanie;Opcja0;Opcja1;Opcja2;Opcja3;indeks_poprawnej
Czym jest typ generyczny?;Typ generyczny to specjalna klasa która automatycznie może generować inne klasy potomne w czasie kompilacji używając reflection API dostępnego w javac;Typ generyczny to typ sparametryzowany z parametrem typu. Przykład: List<String> gdzie String jest parametrem;Typ generyczny to specjalny interfejs funkcyjny wprowadzony w Java 8 który pozwala na przekazywanie typów jako parametrów do wyrażeń lambda;Typ generyczny to uniwersalny typ Object używany we wszystkich kolekcjach jako bazowy typ dla wszystkich operacji w Java Collections Framework;1
Dlaczego typy generyczne zostały wprowadzone?;Aby znacząco zwiększyć wydajność operacji na kolekcjach przez automatyczną specjalizację kodu maszynowego generowanego przez kompilator Just-In-Time w JVM;Aby zapewnić type safety w Collections. Eliminuje castowanie i daje compile-time checks;Aby całkowicie zastąpić tablice jako główną i preferowaną strukturę danych w ekosystemie Java oraz zredukować wykorzystanie tablic natywnych;Aby umożliwić multiple inheritance w Java co było niemożliwe przed wprowadzeniem generics w Java 5 zgodnie z JSR-14;1
Jakie są zalety typów generycznych?;Jedyną istotną zaletą jest znacząco lepsza wydajność osiągana przez specjalistyczne optymalizacje JIT compiler które eliminują overhead związany z boxing;Type safety (compile-time), eliminuje castowanie, czytelność kodu, reuse;Główną zaletą jest możliwość tworzenia tablicy dowolnego typu w runtime co nie było możliwe w wersjach przed Java 5;Kluczową zaletą jest automatyczne zarządzanie pamięcią dla obiektów generycznych przez dedykowany garbage collector wprowadzony specjalnie dla typów parametryzowanych;1
Jak wygląda sygnatura metody generycznej?;<T> T getFirst(List<T> list) { return list.get(0); } gdzie T jest parametrem typu;T getFirst<T>(List list) { return (T)list.get(0); } używając składni podobnej do C++ templates gdzie parametr typu jest podawany po nazwie metody;generic T getFirst(List<T> list) { return list.get(0); } używając specjalnego słowa kluczowego generic wprowadzonego w Java 5 dla oznaczania metod generycznych;List<T>.T getFirst() { return this.get(0); } używając notacji dot syntax gdzie parametr typu jest związany z typem kolekcji;0
Jak wygląda interfejs i/lub klasa generyczna?;interface Repository<T> { T findById(int id); } class UserRepository implements Repository<User>;generic interface Repository { Object findById(int id); } używając słowa kluczowego generic przed interface dla oznaczenia że interfejs jest generyczny;interface<T> Repository { T findById(int id); } gdzie parametr typu jest umieszczany przed nazwą interfejsu zgodnie z konwencją JSR-14;interface Repository implements Generic<T> { T findById(int id); } gdzie każdy interfejs generyczny musi implementować specjalny marker interface Generic;0
Czym jest tak zwany raw type?;Raw type to specjalny typ reprezentujący wartość pustą null w kontekście kolekcji generycznych używany do inicjalizacji bez wartości początkowej;Raw type to generyczne klasy bez parametru typu. Przykład: List (zamiast List<String>). Powoduje unchecked warnings;Raw type to typ prosty primitive type w kontekście programowania generycznego który nie może być użyty bezpośrednio jako parametr typu;Raw type to przestarzała nazwa wprowadzona w Java 1.4 dla uniwersalnego typu Object używana przed wprowadzeniem właściwych generics w Java 5;1
Czym jest inferencja typów?;Inferencja to zaawansowany mechanizm automatycznego rzutowania typów wykonywany przez JVM w runtime dla optymalizacji wydajności operacji na kolekcjach generycznych;Kompilator automatycznie dedukcuje typ. Przykład: List<String> list = new ArrayList<>();;Inferencja to specjalny mechanizm sprawdzania zgodności typów działający w runtime który weryfikuje poprawność operacji na kolekcjach generycznych;Inferencja to deprecated feature wprowadzony tymczasowo w Java 7 który został zastąpiony przez bardziej zaawansowany mechanizm var inference w Java 10;1
Czym są tak zwane wildcards?;Wildcards to znaki zapytania (?) w generics. Pozwalają na bardziej elastyczne typy;Wildcards to specjalne operatory * i ? używane w zaawansowanym pattern matching dla typów generycznych wprowadzone w Java 8 wraz z lambdami;Wildcards to dedykowane placeholder symbole reprezentujące wartości null w deklaracjach typów generycznych używane do inicjalizacji opcjonalnych parametrów;Wildcards to zmienne bez określonego typu wprowadzone przez słowo kluczowe var w Java 10 które automatycznie dedukują typ na podstawie kontekstu;0
Czym jest unbounded wildcard? Podaj przykład.;? bez ograniczeń. Przykład: List<?> list; oznacza listę nieznanego typu;? extends Object jest pełną definicją unbounded wildcard. Przykład: List<?> jest dokładnie równoważny List<? extends Object> zgodnie ze specyfikacją Java;? to specjalny wildcard używany wyłącznie w sygnaturach metod ale nigdy w deklaracjach zmiennych czy pól klasy zgodnie z ograniczeniami kompilat ora;Unbounded wildcard to operator * używany w pattern matching dla dopasowywania dowolnego typu w wyrażeniach switch z Java 14;0
Czym jest lower bounded wildcard? Podaj przykład.;? extends Type jest przykładem lower bounded wildcard. Przykład: List<? extends Integer> oznacza listę Integer lub dowolnego jego subtypu;? super Type. Przykład: List<? super Integer> oznacza listę Integer lub jego supertypu;? below Type to składnia używana dla określenia typów niższych w hierarchii dziedziczenia zgodnie z zasadami Liskov Substitution Principle;Lower bounded wildcard nie istnieje w specyfikacji Java, istnieje tylko upper bounded wildcard zgodnie z ograniczeniami type erasure;1
Czym jest upper bounded wildcard? Podaj przykład.;? extends Type. Przykład: List<? extends Number> oznacza listę Number lub jego subtypów;? super Type jest poprawną składnią dla upper bounded wildcard służącą do ograniczenia typu od góry w hierarchii dziedziczenia;? above Type to specjalna notacja używana dla określenia typów wyższych w hierarchii klas zgodnie ze specyfikacją JSR-14;? implements Type jest wymaganą składnią gdy upper bounded wildcard jest używany z interfejsami zamiast klas abstrakcyjnych lub konkretnych;0
Czym jest wymazywanie typów?;Type erasure to mechanizm automatycznego usuwania wartości null z kolekcji generycznych podczas kompilacji dla zapewnienia type safety;Type erasure: generics są usuwane podczas kompilacji. List<String> staje się List<Object> w runtime. Nie można sprawdzić typu w runtime;Type erasure to zaawansowana optymalizacja pamięci wykonywana przez JVM która redukuje wykorzystanie heap memory przez usuwanie nieużywanych informacji o typach;Type erasure to specjalny mechanizm cache'owania informacji o typach w dedicated memory pool dla zwiększenia wydajności operacji reflection;1
Na czym polega zasada PECS? Podaj przykłady.;PECS oznacza Primitive Extends Class Super i jest zasadą używaną podczas pracy z typami prostymi w kontekście generics;Producer Extends, Consumer Super. Jeśli pobierasz z struktury (producer) używaj extends. Jeśli wstawiasz (consumer) używaj super;PECS to akronim Public Extends Common Super określający zasady widoczności dla klas generycznych w różnych pakietach Java;PECS to przestarzała zasada z Java 5 która została całkowicie zastąpiona przez automatyczny mechanizm var type inference wprowadzony w Java 10;1
Jakie ograniczenia posiadają typy generyczne?;Jedynym ograniczeniem typów generycznych jest wymóg aby wszystkie parametry typu musiały dziedziczyć bezpośrednio lub pośrednio z klasy Object;Nie można tworzyć instancji (new T()), nie można tworzyć tablic (T[]), nie można użyć z typami prostymi (int, tylko Integer);Typy generyczne posiadają fundamentalne ograniczenie że nie mogą być w ogóle używane w definicjach interfejsów tylko w klasach konkretnych;Kluczowym ograniczeniem jest że typy generyczne działają wyłącznie dla kolekcji z pakietu java.util i nie mogą być używane w custom classes;1
Czy można utworzyć tablicę typu generycznego np. T[]?;Tak, składnia T[] array = new T[10]; działa poprawnie we wszystkich wersjach Java od wprowadzenia generics w Java 5;Nie, type erasure. Zamiast tego użyj List<T> lub Object[] z castingiem;Tak ale wyłącznie dla bounded types używając składni T[] array = new (T extends Object)[10]; wprowadzonej w Java 8;Tworzenie tablic generycznych stało się możliwe dopiero od Java 11 która wprowadza dedykowane wsparcie dla generic arrays;1
Jak sprawdzić z jakim typem generycznym mamy do czynienia w runtime?;Używając standardowego operatora instanceof w następujący sposób: if (obj instanceof List<String>) dla sprawdzenia konkretnego typu generycznego;Nie można bezpośrednio (type erasure). Ale: method.getGenericParameterTypes(), field.getGenericType();Wystarczy użyć metody getClass().getGenericType() dostępnej na każdym obiekcie Java która zwraca pełną informację o typie generycznym;Należy użyć dedykowanej klasy TypeChecker.check(object) dostępnej w standardowym pakiecie java.lang.reflect wprowadzonej w Java 8;1
Czy typy generyczne zapewniają compile-time safety?;Nie, typy generyczne zapewniają wyłącznie runtime safety poprzez dynamiczne sprawdzanie typów wykonywane przez JVM podczas działania programu;Tak, ale nie runtime safety (type erasure);Typy generyczne zapewniają zarówno compile-time jak i runtime safety dzięki dwufazowemu systemowi weryfikacji typów wbudowanemu w Java;Typy generyczne nie zapewniają żadnej formy type safety ani w compile-time ani w runtime zgodnie z ograniczeniami type erasure;1
Czy polimorfizm realizowany jest przez typy generyczne?;Nie, mechanizmy generics i polimorfizmu są wzajemnie wykluczające się w Java i nie mogą być używane jednocześnie;Tak, generyczne klasy/interfejsy mogą dziedziczć/implementować i będą polimorficzne;Polimorfizm działa wyłącznie dla raw types ale nie dla fully specified generic types ze względu na ograniczenia type erasure;Wprowadzenie typów generycznych w Java 5 całkowicie zastąpiło potrzebę używania tradycyjnego polimorfizmu w nowoczesnym kodzie Java;1
Czym jest unchecked warning i kiedy jest zgłaszany? Jak go rozwiązać?;Unchecked warning to błąd kompilacji kategorii error który bezwzględnie musi być naprawiony przed możliwością uruchomienia programu;Unchecked warning gdy kompilator nie może zweryfikować type safety (np. raw types). Rozwiązanie: @SuppressWarnings("unchecked") lub prawidłowe generics;Unchecked warning to ostrzeżenie które pojawia się wyłącznie w Java 7 i starszych wersjach ale zostało całkowicie wyeliminowane w Java 8;Nie ma możliwości technicznej rozwiązania unchecked warnings, można je jedynie ignorować używając flag kompilacji -Xlint:none;1
Dlaczego IDE/kompilator zgłasza warning przy varargs z typami generycznymi?;Kombinacja varargs z generics jest całkowicie zabroniona od Java 8 i powoduje błąd kompilacji zamiast ostrzeżenia;Varargs i generics mogą tworzyć niezabezpieczony array. Rozwiązanie: @SafeVarargs lub @SuppressWarnings("unchecked");Jest to znany bug w implementacji kompilatora javac który został oficjalnie naprawiony w Java 11 więc warning nie powinien się już pojawiać;Varargs działają całkowicie poprawnie z wszystkimi typami generycznymi, pojawia jący się warning jest fałszywie pozytywny i można go bezpiecznie ignorować;1
Jak zaimplementować metodę equals() dla typu generycznego?;Metoda equals() nie może być w ogóle używana z typami generycznymi ze względu na fundamentalne ograniczenia nałożone przez type erasure;Metoda equals() jest automatycznie generowana przez kompilator dla wszystkich typów generycznych więc nie wymaga ręcznej implementacji;<T> boolean equals(T a, T b) { return a.equals(b); } lub public boolean equals(Object o) w klasie generycznej;Klasy generyczne wymagają obowiązkowej implementacji interfejsu Comparable<T> zamiast nadpisywania metody equals() zgodnie z best practices;2
Czym jest diamond operator <>?;Diamond operator to specjalna składnia służąca wyłącznie do definiowania zagnieżdżonych nested generics w hierarchiach klas i interfejsów;Diamond operator <> (Java 7+) skraca kod. ArrayList<String> list = new ArrayList<>(); zamiast new ArrayList<String>();Diamond operator to przestarzała składnia wprowadzona tymczasowo w Java 5 która nie powinna być już używana w nowoczesnym kodzie;Diamond operator to specjalny operator porównania służący do sprawdzania równoważności typów generycznych w runtime za pomocą reflection;1
