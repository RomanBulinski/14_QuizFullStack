Pytanie;Opcja0;Opcja1;Opcja2;Opcja3;indeks_poprawnej
Czym jest typ generyczny?;Typ generyczny to klasa która może generować inne klasy;Typ generyczny to typ sparametryzowany z parametrem typu. Przykład: List<String> gdzie String jest parametrem;Typ generyczny to interfejs funkcyjny z Java 8;Typ generyczny to uniwersalny typ Object używany wszędzie;1
Dlaczego typy generyczne zostały wprowadzone?;Aby zwiększyć wydajność kolekcji przez specjalizację kodu;Aby zapewnić type safety w Collections. Eliminuje castowanie i daje compile-time checks;Aby zastąpić tablice jako główną strukturę danych;Aby umożliwić multiple inheritance w Java;1
Jakie są zalety typów generycznych?;Tylko lepsza wydajność przez optymalizację JVM;Type safety (compile-time), eliminuje castowanie, czytelność kodu, reuse;Możliwość tworzenia tablicy dowolnego typu;Automatyczne zarządzanie pamięcią dla obiektów;1
Jak wygląda sygnatura metody generycznej?;<T> T getFirst(List<T> list) { return list.get(0); } gdzie T jest parametrem typu;T getFirst<T>(List list) { return (T)list.get(0); };generic T getFirst(List<T> list) { return list.get(0); };List<T>.T getFirst() { return this.get(0); };0
Jak wygląda interfejs i/lub klasa generyczna?;interface Repository<T> { T findById(int id); } class UserRepository implements Repository<User>;generic interface Repository { Object findById(int id); };interface<T> Repository { T findById(int id); };interface Repository implements Generic<T> { T findById(int id); };0
Czym jest tak zwany raw type?;Raw type to typ bez wartości (null);Raw type to generyczne klasy bez parametru typu. Przykład: List (zamiast List<String>). Powoduje unchecked warnings;Raw type to typ prosty (primitive) w kontekście generics;Raw type to przestarzała nazwa dla Object typu;1
Czym jest inferencja typów?;Inferencja to rzutowanie typów automatyczne przez JVM;Kompilator automatycznie dedukcuje typ. Przykład: List<String> list = new ArrayList<>();;Inferencja to mechanizm sprawdzania typów w runtime;Inferencja to deprecated feature z Java 7;1
Czym są tak zwane wildcards?;Wildcards to znaki zapytania (?) w generics. Pozwalają na bardziej elastyczne typy;Wildcards to operatory * i ? używane w pattern matching;Wildcards to placeholder dla null wartości w generics;Wildcards to zmienne bez typu wprowadzone przez var;0
Czym jest unbounded wildcard? Podaj przykład.;? bez ograniczeń. Przykład: List<?> list; oznacza listę nieznanego typu;? extends Object. Przykład: List<?> równy List<? extends Object>;? to wildcard używany tylko w metodach nie w deklaracjach;Unbounded wildcard to * operator z pattern matching;0
Czym jest lower bounded wildcard? Podaj przykład.;? extends Type. Przykład: List<? extends Integer>;? super Type. Przykład: List<? super Integer> oznacza listę Integer lub jego supertypu;? below Type dla typów niższych w hierarchii;Lower bounded nie istnieje w Java, tylko upper bounded;1
Czym jest upper bounded wildcard? Podaj przykład.;? extends Type. Przykład: List<? extends Number> oznacza listę Number lub jego subtypów;? super Type dla ograniczenia od góry;? above Type dla typów wyższych w hierarchii;? implements Type dla interfejsów;0
Czym jest wymazywanie typów?;Type erasure to usuwanie null wartości z generics;Type erasure: generics są usuwane podczas kompilacji. List<String> staje się List<Object> w runtime. Nie można sprawdzić typu w runtime;Type erasure to optymalizacja pamięci przez JVM;Type erasure to mechanizm cache'owania typów dla wydajności;1
Na czym polega zasada PECS? Podaj przykłady.;PECS: Primitive Extends Class Super - zasada dla typów prostych;Producer Extends, Consumer Super. Jeśli pobierasz z struktury (producer) używaj extends. Jeśli wstawiasz (consumer) używaj super;PECS to Public Extends Common Super dla widoczności klas;PECS to przestarzała zasada zastąpiona przez var inference;1
Jakie ograniczenia posiadają typy generyczne?;Tylko ograniczenie że muszą dziedziczyć z Object;Nie można tworzyć instancji (new T()), nie można tworzyć tablic (T[]), nie można użyć z typami prostymi (int, tylko Integer);Typy generyczne nie mogą być używane w interfejsach;Typy generyczne działają tylko dla kolekcji z java.util;1
Czy można utworzyć tablicę typu generycznego np. T[]?;Tak, T[] array = new T[10]; działa poprawnie;Nie, type erasure. Zamiast tego użyj List<T> lub Object[] z castingiem;Tak ale tylko dla bounded types: T extends Object[];Tablice generyczne są możliwe od Java 11;1
Jak sprawdzić z jakim typem generycznym mamy do czynienia w runtime?;instanceof operator: if (obj instanceof List<String>);Nie można bezpośrednio (type erasure). Ale: method.getGenericParameterTypes(), field.getGenericType();Używając getClass().getGenericType() na obiekcie;TypeChecker.check(object) z pakietu java.lang.reflect;1
Czy typy generyczne zapewniają compile-time safety?;Nie, generics są tylko runtime safety;Tak, ale nie runtime safety (type erasure);Generics zapewniają zarówno compile-time jak i runtime safety;Generics nie zapewniają żadnej formy type safety;1
Czy polimorfizm realizowany jest przez typy generyczne?;Nie, generics i polimorfizm są wzajemnie wykluczające;Tak, generyczne klasy/interfejsy mogą dziedziczć/implementować i będą polimorficzne;Polimorfizm działa tylko dla raw types nie dla generics;Generics zastąpiły potrzebę polimorfizmu w Java;1
Czym jest unchecked warning i kiedy jest zgłaszany? Jak go rozwiązać?;Unchecked warning to błąd kompilacji który musi być naprawiony;Unchecked warning gdy kompilator nie może zweryfikować type safety (np. raw types). Rozwiązanie: @SuppressWarnings("unchecked") lub prawidłowe generics;Unchecked warning pojawia się tylko w Java 7 i starszych;Nie można rozwiązać unchecked warnings, można tylko je ignorować;1
Dlaczego IDE/kompilator zgłasza warning przy varargs z typami generycznymi?;Varargs z generics są zabronione od Java 8;Varargs i generics mogą tworzyć niezabezpieczony array. Rozwiązanie: @SafeVarargs lub @SuppressWarnings("unchecked");To bug w kompilatorze który został naprawiony w Java 11;Varargs działają poprawnie z generics, warning jest fałszywy;1
Jak zaimplementować metodę equals() dla typu generycznego?;equals() nie może być używane z generics;equals() jest automatycznie generowane dla typów generycznych;<T> boolean equals(T a, T b) { return a.equals(b); } lub public boolean equals(Object o) w klasie generycznej;Generics wymagają implementacji Comparable zamiast equals;2
Czym jest diamond operator <>?;Diamond operator to syntax dla nested generics;Diamond operator <> (Java 7+) skraca kod. ArrayList<String> list = new ArrayList<>(); zamiast new ArrayList<String>();Diamond operator to przestarzała składnia z Java 5;Diamond operator to operator porównania dla typów generycznych;1
