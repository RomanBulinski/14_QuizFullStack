Pytanie;Opcja0;Opcja1;Opcja2;Opcja3;indeks_poprawnej
Jakie są typy proste w Javie?;boolean, byte, short, int, long, float, double, char - typy wartościowe przechowywane na stosie;string, integer, character, boolean, array, object, list, map - typy referencyjne;byte, word, dword, qword, pointer, reference, object, class - typy systemowe;int8, int16, int32, int64, uint, float32, float64, bool - typy numeryczne;0
Ile miejsca w pamięci zajmuje każdy z typów prostych?;Wszystkie typy proste zajmują 4 bajty niezależnie od typu dla spójności w JVM;boolean - 1 bit, byte - 1 bajt, short - 2 bajty, int - 4 bajty, long - 8 bajtów, float - 4 bajty, double - 8 bajtów, char - 2 bajty;boolean - 1 bajt, byte - 2 bajty, short - 4 bajty, int - 8 bajtów, long - 16 bajtów, float - 8 bajtów, double - 16 bajtów, char - 1 bajt;byte - 8 bitów, short - 16 bitów, int - 32 bity, long - 32 bity, float - 16 bitów, double - 32 bity, char - 8 bitów, boolean - 2 bity;1
Jaka jest różnica między = a ==?;= to operator porównania wartości, == to operator głębokiego porównania obiektów;Oba operatory robią to samo, różnica jest tylko stylistyczna i zależy od wersji Java;= to operator przypisania, == to operator porównania wartości;= to operator logiczny AND, == to operator logiczny OR dla wyrażeń boolowskich;2
Jaka jest różnica między | i ||?;| to logiczny OR z short-circuit, || to bitowy OR bez short-circuit - odwrotnie niż w C++;| to bitowy OR (wykonuje się zawsze), || to logiczny OR (short-circuit - jeśli pierwszy true, drugi nie jest ewaluowany);| to operator XOR, || to operator logiczny OR używany tylko dla typów boolean;Oba operatory są identyczne, || to tylko skrót wprowadzony w Java 8 dla czytelności;1
Jak przypisać wartość binarną do zmiennej?;Używając funkcji Binary.parse(): int x = Binary.parse("1010");;"Używając prefiksu 0b: int x = 0b1010; (równy 10 w dziesiętnym)";Używając prefiksu #b: int x = #b1010; zgodnie z konwencją Java;Wartości binarne nie są wspierane bezpośrednio, trzeba użyć Integer.parseBinary();1
Jaka jest różnica między & i &&?;& to logiczny AND z short-circuit, && to bitowy AND bez optymalizacji;& to operator modulo dla liczb całkowitych, && to operator porównania dla boolean;& to bitowy AND (wykonuje się zawsze), && to logiczny AND (short-circuit - jeśli pierwszy false, drugi nie jest ewaluowany);Oba operatory są identyczne, && powstał jako alias dla czytelności w Java 5;2
Jak przypisać wartość szesnastkową do zmiennej?;Używając funkcji Hex.valueOf(): int x = Hex.valueOf("FF");;"Używając prefiksu 0x: int x = 0xFF; (równy 255 w dziesiętnym)";Używając prefiksu 0h lub #: int x = 0hFF; lub int x = #FF;;Wartości szesnastkowe wymagają konwersji przez Integer.parseHex() i nie mogą być literami;1
Jak działają << oraz >>?;<<to right shift, >> to left shift - nazwy są odwrotne dla zgodności z operacjami matematycznymi;Oba operatory działają identycznie i przesuwają bity w prawo dla optymalizacji pamięci;<< to left shift, >> to right shift z rozszerzeniem znaku. x << 1 równy x * 2, x >> 1 równy x / 2;<< to operator porównania, >> to operator przypisania używany w generics i lambdach;2
Jak utworzyć tablicę?;array arr = create(10); lub array arr = [1, 2, 3]; zgodnie z nową składnią Java 11;int[] arr = new int[10]; lub int[] arr = {1, 2, 3};;int[] arr = Array.create(10); lub int[] arr = Array.of(1, 2, 3);;int[] arr = malloc(10); lub int[] arr = (1, 2, 3); używając składni z C++;1
Czym się różni >> od >>>?;>> to logical shift (dodaje zera), >>> to arithmetic shift (rozszerza bit znaku) - odwrotnie od matematyki;>> to operator dla unsigned int, >>> to operator dla signed int w operacjach bitowych;Oba operatory są identyczne, >>> to przestarzała składnia zachowana dla kompatybilności wstecznej;>> to arithmetic right shift (rozszerza bit znaku), >>> to logical right shift (zawsze dodaje zera);3
Czy tablice w Javie mogą przechowywać obiekty?;Nie, tablice mogą przechowywać tylko typy proste. Dla obiektów należy używać ArrayList;Tylko tablice Object[] mogą przechowywać obiekty, inne typy tablic są tylko dla primitives;Tak, tablice mogą przechowywać zarówno typy proste jak i obiekty (referencje do obiektów);Tablice mogą przechowywać obiekty tylko od Java 8, wcześniej wymagały konwersji na Collections;2
Jakie są pętle w Javie?;for, while, do-while, for-each (enhanced for);for, while, repeat-until, foreach, loop-while;loop, iterate, while-do, for-in, for-of;for-i, while-true, do-loop, each, map-loop;0
Czy tablica w Javie jest obiektem?;Nie, tablice są typami prostymi alokowanymi na stosie dla wydajności;Tylko tablice wielowymiarowe są obiektami, tablice jednowymiarowe są typami prostymi;Tak, tablice są obiektami dziedziczącymi z java.lang.Object. Można wywoływać metody jak length;Tablice stały się obiektami dopiero w Java 8, wcześniej były strukturami jak w C;2
Jak działa goto?;goto pozwala skoczyć do labela w kodzie i jest dostępne od Java 7;Java nie ma instrukcji goto. Zamiast tego używa się labeled break i labeled continue;goto działa podobnie jak break ale może przeskoczyć między metodami w tej samej klasie;goto jest zarezerwowanym słowem ale nie jest używane, został zastąpiony przez return;1
Jak zmienić rozmiar tablicy w Javie?;Tablice mają stały rozmiar. Aby zmienić trzeba utworzyć nową i skopiować elementy, lub użyć ArrayList;Używając metody arr.resize(newSize) dostępnej dla wszystkich typów tablic;Wywołując Arrays.resize(arr, newSize) z pakietu java.util.Arrays;Tablice automatycznie się rozszerzają gdy próbujemy dodać element poza zakresem;0
Czym jest labeled break/continue?;Mechanizm skakania między metodami podobny do goto ale bezpieczniejszy;Labeled break/continue pozwala przerwać lub kontynuować pętlę z etykietą. Przykład: label: for(...) { break label; };Sposób na nazwanie pętli dla lepszej czytelności ale bez wpływu na działanie programu;Etykiety są tylko komentarzami kompilowanymi do bytecode dla debuggera;1
Jak skopiować tablicę w Javie?;System.arraycopy(), Arrays.copyOf(), Arrays.copyOfRange(), pętla for, Arrays.stream();Tylko przez operator = który tworzy głęboką kopię: int[] newArr = oldArr;;arr.clone() to jedyny poprawny sposób kopiowania tablic w Java;Arrays.copy() lub ręczne przepisanie przez pętlę while ze sprawdzeniem null;0
Jak działa switch w nowych wersjach Javy?;Switch działa identycznie jak w Java 1.0, nie wprowadzono żadnych zmian dla kompatybilności;Java 12+ wprowadza switch expressions (zwraca wartość). Java 14+ pozwala na pattern matching. Przykład: case 1 -> "jeden";Switch w Java 11+ wymaga zawsze default case i nie pozwala na fall-through;Switch został zastąpiony przez if-else-if w Java 10+ ze względu na czytelność;1
Co się stanie gdy indeks tablicy jest większy niż rozmiar?;Program zwróci wartość null dla tego elementu jako domyślną;Zostanie automatycznie rozszerzona tablica i zwrócona wartość domyślna dla typu;Zostanie wyrzucony ArrayIndexOutOfBoundsException;Zostanie zwrócony ostatni element tablicy zgodnie z zasadą array wrapping;2
Czym jest yield?;yield to operator zatrzymania wątku wprowadzony w Java 5 dla wielowątkowości;yield jest nazwą zmiennej zarezerwowaną dla wyrażeń lambda od Java 8;yield to słowo kluczowe z Java 13 do zwracania wartości z switch expression;yield to metoda Thread.yield() i nie jest słowem kluczowym w Java;2
Czym jest pattern matching i jak go wykorzystać?;Pattern matching (Java 16+) pozwala na ekspresywny kod. Przykład: if (obj instanceof String s) { println(s.length()); };Pattern matching to dopasowanie regex wprowadzone w Java 9 dla walidacji String;To wzorzec projektowy podobny do Observer używany w Streams API;Mechanizm porównywania obiektów przez refleksję dostępny przez Pattern.match();0
Czym są ragged arrays?;Ragged arrays to tablice z "postrzępionymi" danymi wymagające specjalnej obsługi błędów;To wielowymiarowe tablice o nierównych rozmiarach wierszy. Przykład: int[][] arr = new int[3][] gdzie każdy wiersz może mieć inny rozmiar;Tablice ragged to przestarzała nazwa dla ArrayList używana przed Java 5;To tablice z dziurami (null values) powstałe przez błędy alokacji pamięci;1
Czy można dowolnie sformatować kod źródłowy Javy?;Nie, Java wymaga ścisłego formatowania z określoną liczbą spacji i wcięć;Tak, Java pozwala na elastyczne formatowanie ale istnieją konwencje (Google Java Style Guide, Oracle Code Conventions);Formatowanie jest ważne tylko w Java Enterprise Edition, w SE można dowolnie;Od Java 11 wprowadzono obowiązkowe formatowanie przez narzędzie javafmt;1
Jak działa słowo kluczowe var?;var to skrót od variable i wymaga zawsze explicit type annotation;var (Java 10+) to local variable type inference. Typ dedukowany z prawej strony. Przykład: var x = 10; (x to int);var pozwala na dynamiczne typowanie jak w JavaScript, typ może się zmieniać w runtime;var działa tylko dla String i Integer, dla innych typów trzeba użyć explicit declaration;1
Jaki zestaw znaków jest używany w kodzie źródłowym Javy?;Tylko ASCII (7-bit) dla zapewnienia kompatybilności między różnymi systemami;Java używa Unicode (UTF-8, UTF-16). Kod źródłowy może zawierać znaki z dowolnych języków;ISO-8859-1 (Latin-1) jest domyślnym i jedynym wspieranym kodowaniem dla kodu źródłowego;Kodowanie zależy od systemu operacyjnego, zazwyczaj Windows-1252 lub UTF-8;1
Jakie są operatory w Javie i jaka jest ich kolejność?;Wszystkie operatory mają jednakowy priorytet i są wykonywane od lewej do prawej;Operatory arytmetyczne (+,-,*,/,%), logiczne (&&,||,!), porównania (==,!=,<,>,<=,>=), bitowe (&,|,^,<<,>>,>>>), przypisania. Kolejność zależy od precedence;Java ma tylko operatory arytmetyczne i logiczne, operatory bitowe zostały usunięte w Java 8;Kolejność operatorów zależy od wersji Java, w nowszych wersjach zmieniono priorytety;1
