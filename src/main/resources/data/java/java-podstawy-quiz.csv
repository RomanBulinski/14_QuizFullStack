Pytanie;Opcja0;Opcja1;Opcja2;Opcja3;indeks_poprawnej
Jakie są typy proste w Javie?;boolean, byte, short, int, long, float, double, char - typy wartościowe przechowywane na stosie;string, integer, character, boolean, array, object, list, map - typy referencyjne będące obiektami w hierarchii klas Java;byte, word, dword, qword, pointer, reference, object, class - typy systemowe używane wewnętrznie przez JVM;int8, int16, int32, int64, uint, float32, float64, bool - typy numeryczne z określoną precyzją bitową;0
Ile miejsca w pamięci zajmuje każdy z typów prostych?;Wszystkie typy proste zajmują dokładnie 4 bajty niezależnie od typu dla spójności operacji arytmetycznych w JVM;boolean - 1 bit, byte - 1 bajt, short - 2 bajty, int - 4 bajty, long - 8 bajtów, float - 4 bajty, double - 8 bajtów, char - 2 bajty;boolean - 1 bajt, byte - 2 bajty, short - 4 bajty, int - 8 bajtów, long - 16 bajtów, float - 8 bajtów, double - 16 bajtów, char - 1 bajt;byte - 8 bitów, short - 16 bitów, int - 32 bity, long - 32 bity, float - 16 bitów, double - 32 bity, char - 8 bitów, boolean - 2 bity;1
Jaka jest różnica między = a ==?;= to operator porównania wartości obiektów, == to operator głębokiego porównania wszystkich pól obiektów przez reflection;Oba operatory robią dokładnie to samo, różnica jest tylko stylistyczna i zależy od preferencji programisty oraz wersji Java;= to operator przypisania, == to operator porównania wartości;= to operator logiczny AND dla wyrażeń boolowskich, == to operator logiczny OR używany w warunkach if;2
Jaka jest różnica między | i ||?;| to logiczny OR z short-circuit evaluation, || to bitowy OR bez short-circuit - działanie odwrotne niż w języku C++;| to bitowy OR (wykonuje się zawsze), || to logiczny OR (short-circuit - jeśli pierwszy true, drugi nie jest ewaluowany);| to operator XOR dla wartości boolean, || to operator logiczny OR używany tylko dla typów boolean w warunkach;Oba operatory są całkowicie identyczne w działaniu, || to tylko skrót wprowadzony w Java 8 dla czytelności kodu;1
Jak przypisać wartość binarną do zmiennej?;Używając funkcji Binary.parse() z pakietu java.lang: int x = Binary.parse("1010") dla konwersji string na binary;Używając prefiksu 0b: int x = 0b1010; (równy 10 w dziesiętnym);Używając prefiksu #b: int x = #b1010; zgodnie z konwencją składniową Java podobną do innych języków jak Ruby;Wartości binarne nie są wspierane bezpośrednio w Java, trzeba zawsze użyć Integer.parseBinary() dla konwersji;1
Jaka jest różnica między & i &&?;& to logiczny AND z short-circuit evaluation, && to bitowy AND bez optymalizacji wykonujący obie strony wyrażenia;& to operator modulo dla liczb całkowitych podobny do % ale z inną semantyką dla wartości ujemnych;& to bitowy AND (wykonuje się zawsze), && to logiczny AND (short-circuit - jeśli pierwszy false, drugi nie jest ewaluowany);Oba operatory są całkowicie identyczne w działaniu, && powstał jako alias dla czytelności w Java 5 podczas dodawania generics;2
Jak przypisać wartość szesnastkową do zmiennej?;Używając funkcji Hex.valueOf() z pakietu java.lang: int x = Hex.valueOf("FF") dla konwersji string na hex;Używając prefiksu 0x: int x = 0xFF; (równy 255 w dziesiętnym);Używając prefiksu 0h lub #: int x = 0hFF; lub int x = #FF; zgodnie ze standardem hexadecimal notation;Wartości szesnastkowe wymagają zawsze konwersji przez Integer.parseHex() i nie mogą być reprezentowane jako litery w kodzie;1
Jak działają << oraz >>?;<<to right shift przesuwający bity w prawo, >> to left shift w lewo - nazwy są odwrotne dla zgodności z matematycznymi operacjami;Oba operatory działają identycznie przesuwając bity w prawo dla optymalizacji pamięci oraz szybkości obliczeń arytmetycznych;<< to left shift, >> to right shift z rozszerzeniem znaku. x << 1 równy x * 2, x >> 1 równy x / 2;<< to operator porównania dla generics, >> to operator przypisania używany w lambda expressions oraz method references;2
Jak utworzyć tablicę?;array arr = create(10); lub array arr = [1, 2, 3]; zgodnie z nową składnią wprowadzoną w Java 11 dla uproszczenia;int[] arr = new int[10]; lub int[] arr = {1, 2, 3};;int[] arr = Array.create(10); lub int[] arr = Array.of(1, 2, 3); używając factory methods z klasy Array;int[] arr = malloc(10); lub int[] arr = (1, 2, 3); używając składni z języka C++ dla kompatybilności z native code;1
Czym się różni >> od >>>?;>> to logical shift dodający zera, >>> to arithmetic shift rozszerzający bit znaku - działanie odwrotne od matematycznego;>> to operator dla unsigned int, >>> to operator dla signed int w operacjach bitowych na liczbach całkowitych;Oba operatory są całkowicie identyczne, >>> to przestarzała składnia zachowana tylko dla kompatybilności wstecznej z Java 1.0;>> to arithmetic right shift (rozszerza bit znaku), >>> to logical right shift (zawsze dodaje zera);3
Czy tablice w Javie mogą przechowywać obiekty?;Nie, tablice mogą przechowywać tylko typy proste primitive types. Dla obiektów należy zawsze używać ArrayList lub innych kolekcji;Tylko tablice Object[] mogą przechowywać obiekty reference types, inne typy tablic są wyłącznie dla primitive values;Tak, tablice mogą przechowywać zarówno typy proste jak i obiekty (referencje do obiektów);Tablice mogą przechowywać obiekty tylko od Java 8, wcześniej wymagały konwersji na Collections Framework structures;2
Jakie są pętle w Javie?;for, while, do-while, for-each (enhanced for);for, while, repeat-until, foreach, loop-while jako główne konstrukcje iteracyjne dostępne w języku;loop, iterate, while-do, for-in, for-of zgodnie ze standardem ECMAScript dla kompatybilności z JavaScript;for-i, while-true, do-loop, each, map-loop jako pięć podstawowych typów pętli w Java;0
Czy tablica w Javie jest obiektem?;Nie, tablice są typami prostymi primitive types alokowanymi na stosie dla wydajności podobnie jak int czy char;Tylko tablice wielowymiarowe są obiektami reference types, tablice jednowymiarowe są typami prostymi dla optymalizacji pamięci;Tak, tablice są obiektami dziedziczącymi z java.lang.Object. Można wywoływać metody jak length;Tablice stały się obiektami dopiero w Java 8, wcześniej były strukturami podobnymi do C bez metod i dziedziczenia;2
Jak działa goto?;goto pozwala skoczyć bezpośrednio do labela w kodzie i jest dostępne od Java 7 dla backward compatibility z C;Java nie ma instrukcji goto. Zamiast tego używa się labeled break i labeled continue;goto działa podobnie jak break ale może przeskoczyć między metodami w tej samej klasie lub pakiecie;goto jest zarezerwowanym słowem kluczowym ale nie jest używane, został całkowicie zastąpiony przez return i break;1
Jak zmienić rozmiar tablicy w Javie?;Tablice mają stały rozmiar. Aby zmienić trzeba utworzyć nową i skopiować elementy, lub użyć ArrayList;Używając metody arr.resize(newSize) dostępnej dla wszystkich typów tablic od Java 7 jako metoda instance;Wywołując Arrays.resize(arr, newSize) z pakietu java.util.Arrays która tworzy nową tablicę z zachowaniem elementów;Tablice automatycznie się rozszerzają gdy próbujemy dodać element poza zakresem przez dynamic array mechanism JVM;0
Czym jest labeled break/continue?;Mechanizm skakania między metodami podobny do goto ale bezpieczniejszy i ograniczony do metod w tej samej klasie;Labeled break/continue pozwala przerwać lub kontynuować pętlę z etykietą. Przykład: label: for(...) { break label; };Sposób na nazwanie pętli dla lepszej czytelności kodu ale bez żadnego wpływu na faktyczne działanie programu;Etykiety są tylko komentarzami które są kompilowane do bytecode dla debuggera oraz stack trace analysis;1
Jak skopiować tablicę w Javie?;System.arraycopy(), Arrays.copyOf(), Arrays.copyOfRange(), pętla for, Arrays.stream();Tylko przez operator = który automatycznie tworzy głęboką kopię wszystkich elementów: int[] newArr = oldArr;;arr.clone() to jedyny poprawny i bezpieczny sposób kopiowania tablic w Java zgodnie z dokumentacją Oracle;Arrays.copy() lub ręczne przepisanie elementów przez pętlę while ze sprawdzeniem null dla każdego elementu;0
Jak działa switch w nowych wersjach Javy?;Switch działa identycznie jak w Java 1.0, nie wprowadzono żadnych zmian składniowych dla zachowania kompatybilności wstecznej;Java 12+ wprowadza switch expressions (zwraca wartość). Java 14+ pozwala na pattern matching. Przykład: case 1 -> "jeden";Switch w Java 11+ wymaga zawsze default case i nie pozwala na fall-through behavior dla bezpieczeństwa typu;Switch został całkowicie zastąpiony przez if-else-if chains w Java 10+ ze względu na lepszą czytelność i type safety;1
Co się stanie gdy indeks tablicy jest większy niż rozmiar?;Program zwróci automatycznie wartość null dla tego elementu jako domyślną wartość dla typu referencyjnego;Zostanie automatycznie rozszerzona tablica do nowego rozmiaru i zwrócona wartość domyślna dla typu primitive lub null;Zostanie wyrzucony ArrayIndexOutOfBoundsException;Zostanie zwrócony ostatni element tablicy zgodnie z zasadą array wrapping podobną do operacji modulo;2
Czym jest yield?;yield to operator zatrzymania wątku wprowadzony w Java 5 dla wielowątkowości podobny do Thread.sleep() ale bez parametru czasu;yield jest nazwą zmiennej zarezerwowaną dla wyrażeń lambda od Java 8 i nie może być używana jako identyfikator;yield to słowo kluczowe z Java 13 do zwracania wartości z switch expression;yield to tylko metoda Thread.yield() i nigdy nie było słowem kluczowym w żadnej wersji języka Java;2
Czym jest pattern matching i jak go wykorzystać?;Pattern matching (Java 16+) pozwala na ekspresywny kod. Przykład: if (obj instanceof String s) { println(s.length()); };Pattern matching to mechanizm dopasowania regex wprowadzony w Java 9 dla walidacji String i parsowania tekstu;To wzorzec projektowy podobny do Observer używany wewnętrznie w Streams API dla przetwarzania sekwencyjnego danych;Mechanizm automatycznego porównywania obiektów przez refleksję dostępny przez Pattern.match() z pakietu java.util.pattern;0
Czym są ragged arrays?;Ragged arrays to tablice z "postrzępionymi" uszkodzonymi danymi wymagające specjalnej obsługi błędów przez try-catch;To wielowymiarowe tablice o nierównych rozmiarach wierszy. Przykład: int[][] arr = new int[3][] gdzie każdy wiersz może mieć inny rozmiar;Tablice ragged to przestarzała nazwa dla ArrayList używana w dokumentacji Java przed wersją 5 i wprowadzeniem generics;To tablice z dziurami jako null values powstałe przez błędy alokacji pamięci w heap podczas konstrukcji obiektów;1
Czy można dowolnie sformatować kod źródłowy Javy?;Nie, Java wymaga ścisłego formatowania z określoną dokładną liczbą spacji oraz wcięć zgodnie z JLS specification;Tak, Java pozwala na elastyczne formatowanie ale istnieją konwencje (Google Java Style Guide, Oracle Code Conventions);Formatowanie jest ważne tylko w Java Enterprise Edition, w Standard Edition można formatować kod całkowicie dowolnie;Od Java 11 wprowadzono obowiązkowe automatyczne formatowanie przez wbudowane narzędzie javafmt compiler plugin;1
Jak działa słowo kluczowe var?;var to skrót od variable i wymaga zawsze explicit type annotation dla czytelności: var int x = 10;var (Java 10+) to local variable type inference. Typ dedukowany z prawej strony. Przykład: var x = 10; (x to int);var pozwala na dynamiczne typowanie jak w JavaScript, typ zmiennej może się zmieniać w runtime podczas wykonania;var działa tylko dla String i Integer, dla wszystkich innych typów trzeba użyć explicit type declaration;1
Jaki zestaw znaków jest używany w kodzie źródłowym Javy?;Tylko ASCII (7-bit) dla zapewnienia kompatybilności między różnymi systemami operacyjnymi oraz platformami;Java używa Unicode (UTF-8, UTF-16). Kod źródłowy może zawierać znaki z dowolnych języków;ISO-8859-1 (Latin-1) jest domyślnym i jedynym wspieranym kodowaniem dla kodu źródłowego Java według specyfikacji JLS;Kodowanie zależy całkowicie od systemu operacyjnego, zazwyczaj Windows-1252 na Windows lub UTF-8 na Linux;1
Jakie są operatory w Javie i jaka jest ich kolejność?;Wszystkie operatory mają jednakowy priorytet i są zawsze wykonywane od lewej do prawej strony bez wyjątków;Operatory arytmetyczne (+,-,*,/,%), logiczne (&&,||,!), porównania (==,!=,<,>,<=,>=), bitowe (&,|,^,<<,>>,>>>), przypisania. Kolejność zależy od precedence;Java ma tylko operatory arytmetyczne i logiczne, operatory bitowe zostały usunięte w Java 8 dla uproszczenia języka;Kolejność operatorów zależy od wersji Java, w nowszych wersjach zmieniono priorytety dla lepszej semantyki wyrażeń;1
